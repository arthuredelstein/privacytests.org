{"all_tests":[{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p","readDifferentSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p","readDifferentSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p","readDifferentSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_1p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_1574549459456729","readDifferentSession":"fake_1574549459456729"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p","readDifferentSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p","readDifferentSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p","readDifferentSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"9a9d8eed-6bd3-4060-9315-c574bed4e9de_3p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5385062884184888","readDifferentSession":"fake_5385062884184888"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T15:35:50.216Z","reportedVersion":"122.0.6261.94","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p","readDifferentSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p","readDifferentSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p","readDifferentSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_1p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6085037892239791","readDifferentSession":"fake_6085037892239791"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p","readDifferentSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p","readDifferentSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p","readDifferentSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"b4abb95d-6930-4185-990c-bd34e4a78a2c_3p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_08077594135932276","readDifferentSession":"fake_08077594135932276"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T15:37:42.409Z","reportedVersion":"122.0.6261.94","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p","readDifferentSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p","readDifferentSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p","readDifferentSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_1p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_37968285955148584","readDifferentSession":"fake_37968285955148584"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p","readDifferentSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p","readDifferentSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p","readDifferentSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"30cd67fb-9dfa-4c90-9916-e1bdd59a13d5_3p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_3384461773674532","readDifferentSession":"fake_3384461773674532"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T15:39:30.475Z","reportedVersion":"122.0.6261.94","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p","readDifferentSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p","readDifferentSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p","readDifferentSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_1p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7864669249617313","readDifferentSession":"fake_7864669249617313"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p","readDifferentSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p","readDifferentSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p","readDifferentSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"248a5051-eef8-4987-9196-e8d52b0ed3f1_3p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_08367051323506525","readDifferentSession":"fake_08367051323506525"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T15:41:44.948Z","reportedVersion":"122.0.6261.94","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_1p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_1p","readDifferentSession":"74580df3-9273-47aa-a241-0951c8f19295_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_1p","readDifferentSession":"74580df3-9273-47aa-a241-0951c8f19295_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_1p","readDifferentSession":"74580df3-9273-47aa-a241-0951c8f19295_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_1p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9288362791502103","readDifferentSession":"fake_9288362791502103"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_3p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_3p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_3p","readDifferentSession":"74580df3-9273-47aa-a241-0951c8f19295_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_3p","readDifferentSession":"74580df3-9273-47aa-a241-0951c8f19295_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_3p","readDifferentSession":"74580df3-9273-47aa-a241-0951c8f19295_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"74580df3-9273-47aa-a241-0951c8f19295_3p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_3348608657389889","readDifferentSession":"fake_3348608657389889"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T15:43:31.923Z","reportedVersion":"122.0.6261.94","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"}],"git":"80fc570d31071130f3fe7e4c677e299bad287783","timeStarted":"2024-02-28T15:35:50.199Z","timeStopped":"2024-02-28T15:45:20.032Z","platform":"Desktop"}