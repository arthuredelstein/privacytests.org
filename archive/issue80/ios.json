{"all_tests":[{"browser":"firefox","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"727c5125-5016-44e1-9d14-a48c57729d53_1p_js","readDifferentSession":"727c5125-5016-44e1-9d14-a48c57729d53_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"727c5125-5016-44e1-9d14-a48c57729d53_1p","readDifferentSession":"727c5125-5016-44e1-9d14-a48c57729d53_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"727c5125-5016-44e1-9d14-a48c57729d53_1p","readDifferentSession":"727c5125-5016-44e1-9d14-a48c57729d53_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p","readDifferentSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7519931018271657","readDifferentSession":"fake_7519931018271657"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":null,"readDifferentSession":null},"indexedDB":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8608935905016684","readDifferentSession":"fake_8608935905016684"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":526,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1365,"desired_max_value":1385},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1365,"desired_max_value":1385},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1365,"desired_max_value":1385}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"727c5125-5016-44e1-9d14-a48c57729d53","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_727c5125-5016-44e1-9d14-a48c57729d53","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"727c5125-5016-44e1-9d14-a48c57729d53_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"727c5125-5016-44e1-9d14-a48c57729d53_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"727c5125-5016-44e1-9d14-a48c57729d53","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"727c5125-5016-44e1-9d14-a48c57729d53","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"727c5125-5016-44e1-9d14-a48c57729d53","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"9ad672acc3a4be8ff2ccdb543714a5f97d861f6784037596277ed5ae9a563ed3","readDifferentFirstParty":"091ae8f1077392b746345be29c277a220bf1ee7f6f258824962fcbfbc9cf09a9","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"727c5125-5016-44e1-9d14-a48c57729d53","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"727c5125-5016-44e1-9d14-a48c57729d53","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"34fa831532d33412a0abc2833cf494a8","readDifferentFirstParty":"0761ba01f16ab10bda049a49d0fd1c55","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_49119494594054913","readDifferentFirstParty":"fake_4352535556777095","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T04:35:51.430Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"safari","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"bb60a56e-b6c7-47be-b416-b49bf148ffe0_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bb60a56e-b6c7-47be-b416-b49bf148ffe0_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bb60a56e-b6c7-47be-b416-b49bf148ffe0_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_12623937138326613","readDifferentSession":"fake_1885986332417524"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bb60a56e-b6c7-47be-b416-b49bf148ffe0_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bb60a56e-b6c7-47be-b416-b49bf148ffe0_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_4571928221457109","readDifferentSession":"fake_06620565320440353"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":1428,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":true,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1418,"desired_max_value":1438},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1418,"desired_max_value":1438},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1418,"desired_max_value":1438}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"bb60a56e-b6c7-47be-b416-b49bf148ffe0","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_bb60a56e-b6c7-47be-b416-b49bf148ffe0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"bb60a56e-b6c7-47be-b416-b49bf148ffe0_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"bb60a56e-b6c7-47be-b416-b49bf148ffe0_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"bb60a56e-b6c7-47be-b416-b49bf148ffe0","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"bb60a56e-b6c7-47be-b416-b49bf148ffe0","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"3b3add96b169283f241170b8b1dc651c3e658f5beb9dfb1dceba83fffbf19aa4","readDifferentFirstParty":"f0346f5810f3fe07aa7ad6a1d2cc7cd3097a7de36a916a07608836c80ef950a6","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bb60a56e-b6c7-47be-b416-b49bf148ffe0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bb60a56e-b6c7-47be-b416-b49bf148ffe0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_031821510807725106","readDifferentFirstParty":"fake_24290694318555484","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T04:42:25.333Z","reportedVersion":"17.2.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"yandex","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"823bb443-80ba-4cdf-8cba-7d14af5ce078_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"823bb443-80ba-4cdf-8cba-7d14af5ce078_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"823bb443-80ba-4cdf-8cba-7d14af5ce078_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"823bb443-80ba-4cdf-8cba-7d14af5ce078_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_620137757615147","readDifferentSession":"fake_26968432692138156"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"823bb443-80ba-4cdf-8cba-7d14af5ce078_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"823bb443-80ba-4cdf-8cba-7d14af5ce078_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"823bb443-80ba-4cdf-8cba-7d14af5ce078_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_17605699370388894","readDifferentSession":"fake_757400446673131"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1388,"desired_max_value":1408},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1388,"desired_max_value":1408},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1388,"desired_max_value":1408}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"823bb443-80ba-4cdf-8cba-7d14af5ce078","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_823bb443-80ba-4cdf-8cba-7d14af5ce078","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"823bb443-80ba-4cdf-8cba-7d14af5ce078_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"823bb443-80ba-4cdf-8cba-7d14af5ce078_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"823bb443-80ba-4cdf-8cba-7d14af5ce078","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"823bb443-80ba-4cdf-8cba-7d14af5ce078","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"823bb443-80ba-4cdf-8cba-7d14af5ce078","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"33d11f3807c326661ca8f899e3e17217352aa73342e92a4940158be7fff6512c","readDifferentFirstParty":"15417da04e55d0c64805ac496960204bf613604d417538ed958ec2e7e7402122","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"823bb443-80ba-4cdf-8cba-7d14af5ce078","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"823bb443-80ba-4cdf-8cba-7d14af5ce078","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_2763894409904206","readDifferentFirstParty":"fake_48973662654467054","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T04:45:16.341Z","reportedVersion":"2401.1.655","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"focus","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6476841411928904","readDifferentSession":"fake_19135570774306476"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5267089294655765","readDifferentSession":"fake_5640629173698883"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":547,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1419,"desired_max_value":1439},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1419,"desired_max_value":1439},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1419,"desired_max_value":1439}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_6d45cb8e-e3e0-4d32-87bd-545cad51ba2e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"21064e0343d167dd7a0f40f6e57aa4fef1e75725819b35faceeaf7dffd801d63","readDifferentFirstParty":"78be156899971a9c3171db22185f31a992c179a3dfd36eebc7e3f30c4b5e61e1","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"6d45cb8e-e3e0-4d32-87bd-545cad51ba2e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_2202619952457905","readDifferentFirstParty":"fake_3000869700885733","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T04:49:21.546Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"opera","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"cda0f5d8-3324-431c-98db-ad23a34530cd_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"cda0f5d8-3324-431c-98db-ad23a34530cd_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"cda0f5d8-3324-431c-98db-ad23a34530cd_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"cda0f5d8-3324-431c-98db-ad23a34530cd_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_08110346799893176","readDifferentSession":"fake_08110346799893176"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"cda0f5d8-3324-431c-98db-ad23a34530cd_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"cda0f5d8-3324-431c-98db-ad23a34530cd_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"cda0f5d8-3324-431c-98db-ad23a34530cd_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_4190021902084633","readDifferentSession":"fake_4190021902084633"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":555,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1440,"desired_max_value":1460},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1440,"desired_max_value":1460},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1440,"desired_max_value":1460}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"cda0f5d8-3324-431c-98db-ad23a34530cd","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_cda0f5d8-3324-431c-98db-ad23a34530cd","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"cda0f5d8-3324-431c-98db-ad23a34530cd_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"cda0f5d8-3324-431c-98db-ad23a34530cd_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"cda0f5d8-3324-431c-98db-ad23a34530cd","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"cda0f5d8-3324-431c-98db-ad23a34530cd","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"cda0f5d8-3324-431c-98db-ad23a34530cd","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"4048150bdc02b6e16eb438c606cfe1f037dec20ffcedacf73f7549a07e48d62b","readDifferentFirstParty":"cef3bf33786ca24f83f99b0ffa679852a44c8c1b645d41566d8ef29151f329b6","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"cda0f5d8-3324-431c-98db-ad23a34530cd","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"cda0f5d8-3324-431c-98db-ad23a34530cd","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"01d2479d64d442092d2c910cb7332086","readDifferentFirstParty":"c465aaa2044b04b643a2c72c584316a4","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_8350823694086484","readDifferentFirstParty":"fake_948830278204903","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h2","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T04:52:04.008Z","reportedVersion":"4.4.2","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"94e01962-3fb3-410d-a017-eba41565c34a_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"94e01962-3fb3-410d-a017-eba41565c34a_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"94e01962-3fb3-410d-a017-eba41565c34a_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"94e01962-3fb3-410d-a017-eba41565c34a_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8547351028058581","readDifferentSession":"fake_8547351028058581"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"94e01962-3fb3-410d-a017-eba41565c34a_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"94e01962-3fb3-410d-a017-eba41565c34a_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"94e01962-3fb3-410d-a017-eba41565c34a_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5646513363709647","readDifferentSession":"fake_5646513363709647"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1435,"desired_max_value":1455},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1435,"desired_max_value":1455},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1435,"desired_max_value":1455}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"94e01962-3fb3-410d-a017-eba41565c34a","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_94e01962-3fb3-410d-a017-eba41565c34a","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"94e01962-3fb3-410d-a017-eba41565c34a_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"94e01962-3fb3-410d-a017-eba41565c34a_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"94e01962-3fb3-410d-a017-eba41565c34a","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"94e01962-3fb3-410d-a017-eba41565c34a","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"94e01962-3fb3-410d-a017-eba41565c34a","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"14fa41f27b98a7be123550a821b9c4b8af869000733b8571c21cddfdbdd97795","readDifferentFirstParty":"3989899fbdd2f37d4dfa3dd70b7d595adae80e0ce9ecbe6379eb4778509ff0b6","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"94e01962-3fb3-410d-a017-eba41565c34a","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"94e01962-3fb3-410d-a017-eba41565c34a","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"da9deb151e127a3bd9551735ae916b14","readDifferentFirstParty":"5300a4cec65e6929eb87d2227539f782","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_21274494430698732","readDifferentFirstParty":"fake_12995493904450028","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T04:57:45.153Z","reportedVersion":"121.6167.138","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"edge","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_4297024718436435","readDifferentSession":"fake_4297024718436435"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8459193481774745","readDifferentSession":"fake_8459193481774745"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":561,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1456,"desired_max_value":1476},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1456,"desired_max_value":1476},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1456,"desired_max_value":1476}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_1acc35fc-ee83-49ff-bf0b-2edc315a2b6a","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"ed2307e414a0e1091a3e77dd66c3bb0a3d024a88db887b5063269bcc6c88a2ce","readDifferentFirstParty":"3add079e068d8c2c9af266b035197d7e4fab6af12ab15fe6abdf3081d2371d2c","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"1acc35fc-ee83-49ff-bf0b-2edc315a2b6a","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"970446640d77e03f6b6fc36cc4c93075","readDifferentFirstParty":"a3c69ead8da2bb6bcbcd1ec90a96321b","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_5925240857371594","readDifferentFirstParty":"fake_442728202085231","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:00:35.837Z","reportedVersion":"120.2210.150","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"brave","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8489002795590752","readDifferentSession":"fake_8489002795590752"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_020109163532926244","readDifferentSession":"fake_020109163532926244"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":543,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1409,"desired_max_value":1429},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1409,"desired_max_value":1429},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1409,"desired_max_value":1429}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"fb03e514-982d-4d04-b4cd-4bfdf94569d3","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_fb03e514-982d-4d04-b4cd-4bfdf94569d3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"fb03e514-982d-4d04-b4cd-4bfdf94569d3_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"fb03e514-982d-4d04-b4cd-4bfdf94569d3","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"fb03e514-982d-4d04-b4cd-4bfdf94569d3","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"fb03e514-982d-4d04-b4cd-4bfdf94569d3","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"a2d628d62b7d62ec9b6497579df3851443c318094aa14d350723a081f3cb6993","readDifferentFirstParty":"e6f489db8e886bc51f937a2d5b9f9540e43b9ecc8b4cf5a20b1e7032d383b678","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"fb03e514-982d-4d04-b4cd-4bfdf94569d3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"fb03e514-982d-4d04-b4cd-4bfdf94569d3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"572f84c407d33e18b8e2d1d9e91cf714","readDifferentFirstParty":"9792b30a9a5d8b4582084dc39ecceb08","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_8303447453005914","readDifferentFirstParty":"fake_07124738107197581","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:04:24.965Z","reportedVersion":"1.61.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"duckduckgo","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"5710fd62-566d-4c3f-8401-baacd7003ca6_1p_js","readDifferentSession":"5710fd62-566d-4c3f-8401-baacd7003ca6_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"5710fd62-566d-4c3f-8401-baacd7003ca6_1p","readDifferentSession":"5710fd62-566d-4c3f-8401-baacd7003ca6_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"5710fd62-566d-4c3f-8401-baacd7003ca6_1p","readDifferentSession":"5710fd62-566d-4c3f-8401-baacd7003ca6_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7309859116514719","readDifferentSession":"fake_7309859116514719"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"5710fd62-566d-4c3f-8401-baacd7003ca6_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"5710fd62-566d-4c3f-8401-baacd7003ca6_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9264565908817741","readDifferentSession":"fake_9264565908817741"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":546,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1417,"desired_max_value":1437},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1417,"desired_max_value":1437},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1417,"desired_max_value":1437}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"5710fd62-566d-4c3f-8401-baacd7003ca6","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_5710fd62-566d-4c3f-8401-baacd7003ca6","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"5710fd62-566d-4c3f-8401-baacd7003ca6_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"5710fd62-566d-4c3f-8401-baacd7003ca6_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"5710fd62-566d-4c3f-8401-baacd7003ca6","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"5710fd62-566d-4c3f-8401-baacd7003ca6","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"23b31605667796ca51f5ecccd24bf606bdb204ea349884241d233ae29ed071e3","readDifferentFirstParty":"558f4d840e7bc0dd371a8eb89f9b2325734d3300eeadf751e9b4631545869908","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"5710fd62-566d-4c3f-8401-baacd7003ca6","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"5710fd62-566d-4c3f-8401-baacd7003ca6","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"2b8fb7a58cb018affb997d5e3bc14a19","readDifferentFirstParty":"9ab83e2af4df701c8f9a3e1b7ae93f2b","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_39203132418290276","readDifferentFirstParty":"fake_9867626681377977","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:09:21.481Z","reportedVersion":"7.104.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"vivaldi","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_40210259542492843","readDifferentSession":"fake_40210259542492843"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5862151453369371","readDifferentSession":"fake_5862151453369371"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":508,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1318,"desired_max_value":1338},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1318,"desired_max_value":1338},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1318,"desired_max_value":1338}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_bfbfe675-74e8-47bf-8d7f-8ae5db58a99d","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"28c254a8985f3da360fc90b8404c4ac5d87fdf6296fdb8021deb3f2189fb673e","readDifferentFirstParty":"8d2ad33346aafe7be113739ebeebc5aa28ea93532b4664b00ccbf3b085861f97","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bfbfe675-74e8-47bf-8d7f-8ae5db58a99d","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"e95faeef97b1a8e09e2dd4ad9992ddb2","readDifferentFirstParty":"2a0bed35f686a68eb366044730558905","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_008072101001150633","readDifferentFirstParty":"fake_7126744242386343","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:12:08.344Z","reportedVersion":"6.3212.38","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"firefox","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_1p_js","readDifferentSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_1p","readDifferentSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_1p","readDifferentSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p","readDifferentSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9188875774694749","readDifferentSession":"fake_9188875774694749"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"3a437221-377c-4bf3-bed1-bb5323fe4c42_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9520652628743931","readDifferentSession":"fake_9520652628743931"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":526,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1365,"desired_max_value":1385},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1365,"desired_max_value":1385},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1365,"desired_max_value":1385}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"3a437221-377c-4bf3-bed1-bb5323fe4c42","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_3a437221-377c-4bf3-bed1-bb5323fe4c42","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"3a437221-377c-4bf3-bed1-bb5323fe4c42_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"3a437221-377c-4bf3-bed1-bb5323fe4c42_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"3a437221-377c-4bf3-bed1-bb5323fe4c42","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"3a437221-377c-4bf3-bed1-bb5323fe4c42","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"3a437221-377c-4bf3-bed1-bb5323fe4c42","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"06fbdaa1d2fd69ced5ae8f572923277e949a1e1ca5c7e218f60cff9f85fc4c0c","readDifferentFirstParty":"9e5fe405177689e987a8b6e64e461f110bee7eeafd93112903714bf39ea2ebb4","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"3a437221-377c-4bf3-bed1-bb5323fe4c42","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"3a437221-377c-4bf3-bed1-bb5323fe4c42","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"5082ab940c6155ff8908d9384a3cdd43","readDifferentFirstParty":"9511aed13c54749bd2b267df6497e148","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_8796239752264394","readDifferentFirstParty":"fake_9531548805785326","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:15:50.203Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"safari","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"59f0b591-afbf-47c9-92c9-906173b70ee1_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"59f0b591-afbf-47c9-92c9-906173b70ee1_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"59f0b591-afbf-47c9-92c9-906173b70ee1_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5004605611653283","readDifferentSession":"fake_376257074530125"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"59f0b591-afbf-47c9-92c9-906173b70ee1_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"59f0b591-afbf-47c9-92c9-906173b70ee1_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_013884197285937594","readDifferentSession":"fake_9792955485765578"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":1428,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":true,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1418,"desired_max_value":1438},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1418,"desired_max_value":1438},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1418,"desired_max_value":1438}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"59f0b591-afbf-47c9-92c9-906173b70ee1","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_59f0b591-afbf-47c9-92c9-906173b70ee1","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"59f0b591-afbf-47c9-92c9-906173b70ee1_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"59f0b591-afbf-47c9-92c9-906173b70ee1_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"59f0b591-afbf-47c9-92c9-906173b70ee1","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"59f0b591-afbf-47c9-92c9-906173b70ee1","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"cf237d9209a26d349c35ab7a45e7046db8d6c08f4bdf1cdfc1f087c3ce132475","readDifferentFirstParty":"faf3c6a77d42e908e60619e3b6f8dc9609f058357a77429e83344bbb9fadaf61","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"59f0b591-afbf-47c9-92c9-906173b70ee1","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"59f0b591-afbf-47c9-92c9-906173b70ee1","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_3056234022210813","readDifferentFirstParty":"fake_80871287262379","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:22:06.037Z","reportedVersion":"17.2.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"yandex","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e10a1737-063b-4d0c-a93b-373085f4c670_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"e10a1737-063b-4d0c-a93b-373085f4c670_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"e10a1737-063b-4d0c-a93b-373085f4c670_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"e10a1737-063b-4d0c-a93b-373085f4c670_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7104131273109473","readDifferentSession":"fake_9192097083939095"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"e10a1737-063b-4d0c-a93b-373085f4c670_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"e10a1737-063b-4d0c-a93b-373085f4c670_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"e10a1737-063b-4d0c-a93b-373085f4c670_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_2690986124098236","readDifferentSession":"fake_7161736816221362"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1388,"desired_max_value":1408},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1388,"desired_max_value":1408},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1388,"desired_max_value":1408}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"e10a1737-063b-4d0c-a93b-373085f4c670","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_e10a1737-063b-4d0c-a93b-373085f4c670","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"e10a1737-063b-4d0c-a93b-373085f4c670_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"e10a1737-063b-4d0c-a93b-373085f4c670_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"e10a1737-063b-4d0c-a93b-373085f4c670","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"e10a1737-063b-4d0c-a93b-373085f4c670","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"e10a1737-063b-4d0c-a93b-373085f4c670","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"95b6707918e205ca086c93565c0bfad7f38f651de88cb57ed042feceff22e4da","readDifferentFirstParty":"49b91595367f83f5b30d143c6dc14134439d05a39d96bfa653b6056653f80550","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"e10a1737-063b-4d0c-a93b-373085f4c670","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"e10a1737-063b-4d0c-a93b-373085f4c670","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_4733008528607021","readDifferentFirstParty":"fake_994902167459512","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:25:00.984Z","reportedVersion":"2401.1.655","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"focus","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"f2a0d878-b6e3-4f4a-8492-2450704d30e8_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"f2a0d878-b6e3-4f4a-8492-2450704d30e8_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"f2a0d878-b6e3-4f4a-8492-2450704d30e8_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_051758648554463216","readDifferentSession":"fake_2600653883090336"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"f2a0d878-b6e3-4f4a-8492-2450704d30e8_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"f2a0d878-b6e3-4f4a-8492-2450704d30e8_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9398220139623361","readDifferentSession":"fake_8403039177764264"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":547,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1419,"desired_max_value":1439},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1419,"desired_max_value":1439},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1419,"desired_max_value":1439}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"f2a0d878-b6e3-4f4a-8492-2450704d30e8","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_f2a0d878-b6e3-4f4a-8492-2450704d30e8","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"f2a0d878-b6e3-4f4a-8492-2450704d30e8_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"f2a0d878-b6e3-4f4a-8492-2450704d30e8_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"f2a0d878-b6e3-4f4a-8492-2450704d30e8","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"f2a0d878-b6e3-4f4a-8492-2450704d30e8","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"13d1b6f468494d8115a65c38cb8d5ba43334c58d7c6e8114aab5454c2b019df5","readDifferentFirstParty":"8660e8652bcda2b72c1cc17fc49ab000990475a916db85d24ecddd860c57cc8a","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"f2a0d878-b6e3-4f4a-8492-2450704d30e8","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"f2a0d878-b6e3-4f4a-8492-2450704d30e8","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_1814991442253966","readDifferentFirstParty":"fake_8830090224635789","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:29:04.536Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"opera","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5543032459366286","readDifferentSession":"fake_5543032459366286"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7940140996338363","readDifferentSession":"fake_7940140996338363"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":555,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1440,"desired_max_value":1460},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1440,"desired_max_value":1460},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1440,"desired_max_value":1460}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"88d629d5-1148-4d97-bf3b-e2e799fca4d4","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_88d629d5-1148-4d97-bf3b-e2e799fca4d4","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"88d629d5-1148-4d97-bf3b-e2e799fca4d4_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"88d629d5-1148-4d97-bf3b-e2e799fca4d4","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"88d629d5-1148-4d97-bf3b-e2e799fca4d4","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"88d629d5-1148-4d97-bf3b-e2e799fca4d4","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"5003cac3079629753a771affdcc88bf9bdab5b4a40bd6baac81d2f922b5db2b7","readDifferentFirstParty":"bc4b53295d6149217961d947d16dac25d6c30ff916a8f696695350719c1162fc","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"88d629d5-1148-4d97-bf3b-e2e799fca4d4","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"88d629d5-1148-4d97-bf3b-e2e799fca4d4","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"9291095d6203a0d4e64ace0af17bf035","readDifferentFirstParty":"f16b5bab9f75e8aa7fd6ef526e9b7630","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_6253813542535169","readDifferentFirstParty":"fake_05254871052437049","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:31:48.380Z","reportedVersion":"4.4.2","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"2b658358-2240-4670-b6dd-1adc00d202ff_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"2b658358-2240-4670-b6dd-1adc00d202ff_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"2b658358-2240-4670-b6dd-1adc00d202ff_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"2b658358-2240-4670-b6dd-1adc00d202ff_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_0857625627334937","readDifferentSession":"fake_0857625627334937"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"2b658358-2240-4670-b6dd-1adc00d202ff_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"2b658358-2240-4670-b6dd-1adc00d202ff_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"2b658358-2240-4670-b6dd-1adc00d202ff_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6155352820510829","readDifferentSession":"fake_6155352820510829"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1435,"desired_max_value":1455},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1435,"desired_max_value":1455},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1435,"desired_max_value":1455}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"2b658358-2240-4670-b6dd-1adc00d202ff","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_2b658358-2240-4670-b6dd-1adc00d202ff","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"2b658358-2240-4670-b6dd-1adc00d202ff_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"2b658358-2240-4670-b6dd-1adc00d202ff_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"2b658358-2240-4670-b6dd-1adc00d202ff","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"2b658358-2240-4670-b6dd-1adc00d202ff","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"2b658358-2240-4670-b6dd-1adc00d202ff","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"911aafd26a0ef9e5a294801c6637c7839a1d9c02194a596369b115156702e1bf","readDifferentFirstParty":"403dee3fba1fe3609b520aabf01c75d0b95292ebe9a9bace9b3aae3c42c1f0c8","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"2b658358-2240-4670-b6dd-1adc00d202ff","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"2b658358-2240-4670-b6dd-1adc00d202ff","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"da7e9cd20e5b81ca759c968f58e706de","readDifferentFirstParty":"7a0f59cfe888322000c6f1c701690016","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_8009987103354015","readDifferentFirstParty":"fake_4117093440481816","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:37:46.819Z","reportedVersion":"121.6167.138","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"edge","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_3206860255864876","readDifferentSession":"fake_3206860255864876"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_4039838030014473","readDifferentSession":"fake_4039838030014473"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":561,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1456,"desired_max_value":1476},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1456,"desired_max_value":1476},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1456,"desired_max_value":1476}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"bd974a67-21e7-44f4-883f-60bbd69aa7b2","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_bd974a67-21e7-44f4-883f-60bbd69aa7b2","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"bd974a67-21e7-44f4-883f-60bbd69aa7b2_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"bd974a67-21e7-44f4-883f-60bbd69aa7b2","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"bd974a67-21e7-44f4-883f-60bbd69aa7b2","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"bd974a67-21e7-44f4-883f-60bbd69aa7b2","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"d39d73c8a0a30135b21160483982036ec6154e85e5f7e10bfda1e5c95337f75c","readDifferentFirstParty":"2e64b666a0392dd9ad626274fc3c4b9bccc74cd6a99811cf1d25261bb746df07","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bd974a67-21e7-44f4-883f-60bbd69aa7b2","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bd974a67-21e7-44f4-883f-60bbd69aa7b2","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"df81a0e2ba8c881284b9cb36640b18e0","readDifferentFirstParty":"f701a69012a0a742123858c5a59ed90c","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_12149090066379165","readDifferentFirstParty":"fake_07387111079699449","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:40:38.435Z","reportedVersion":"120.2210.150","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"brave","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_3529291562531809","readDifferentSession":"fake_3529291562531809"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_12213731683609086","readDifferentSession":"fake_12213731683609086"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":543,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1409,"desired_max_value":1429},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1409,"desired_max_value":1429},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1409,"desired_max_value":1429}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"3a8d01cc-05d4-4b42-a64d-682ee2d81801","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_3a8d01cc-05d4-4b42-a64d-682ee2d81801","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"3a8d01cc-05d4-4b42-a64d-682ee2d81801_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"3a8d01cc-05d4-4b42-a64d-682ee2d81801","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"3a8d01cc-05d4-4b42-a64d-682ee2d81801","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"3a8d01cc-05d4-4b42-a64d-682ee2d81801","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"f08ebf3781bdcb502ce5cfa6ec11c0588d942a04707ad468be3eca5c7fc8a22a","readDifferentFirstParty":"27358e649e573e9df8bed5e88d65ffcdcb22af216bbc4b25f38405328014412c","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"3a8d01cc-05d4-4b42-a64d-682ee2d81801","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"3a8d01cc-05d4-4b42-a64d-682ee2d81801","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"6ecdff68f3565a23e0d553771c862b0e","readDifferentFirstParty":"f12861010c45c765e803f6b70d8ca1e8","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_38844012266949357","readDifferentFirstParty":"fake_848815132271872","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:43:27.442Z","reportedVersion":"1.61.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"duckduckgo","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_1p_js","readDifferentSession":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_1p","readDifferentSession":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_1p","readDifferentSession":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_37768565297092094","readDifferentSession":"fake_37768565297092094"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_3522555679483894","readDifferentSession":"fake_3522555679483894"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":546,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1417,"desired_max_value":1437},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1417,"desired_max_value":1437},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1417,"desired_max_value":1437}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_6963b49f-97ec-41aa-a44d-1eab53ddcf1b","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"0c7d32bca95a6d29a6516ebb7b436f4ec48c70f7921307176e5c40a1dd62f12c","readDifferentFirstParty":"5215b377797ddee0edf20cfb833bafbf3ec5698b1673749ea80b91ed588f5ddf","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"6963b49f-97ec-41aa-a44d-1eab53ddcf1b","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"aada00caefcad074a29ea7b875c43770","readDifferentFirstParty":"61e374afe8eb96bbaa0ebe99ae12f8c4","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_05294699171712747","readDifferentFirstParty":"fake_6168888153916141","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:48:21.560Z","reportedVersion":"7.104.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"vivaldi","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"b141b083-dfa5-46fc-bfcc-14458b4d4600_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"b141b083-dfa5-46fc-bfcc-14458b4d4600_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"b141b083-dfa5-46fc-bfcc-14458b4d4600_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"b141b083-dfa5-46fc-bfcc-14458b4d4600_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_40265097675093187","readDifferentSession":"fake_40265097675093187"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"b141b083-dfa5-46fc-bfcc-14458b4d4600_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"b141b083-dfa5-46fc-bfcc-14458b4d4600_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"b141b083-dfa5-46fc-bfcc-14458b4d4600_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8069595540676837","readDifferentSession":"fake_8069595540676837"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":508,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1318,"desired_max_value":1338},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1318,"desired_max_value":1338},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1318,"desired_max_value":1338}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"b141b083-dfa5-46fc-bfcc-14458b4d4600","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_b141b083-dfa5-46fc-bfcc-14458b4d4600","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"b141b083-dfa5-46fc-bfcc-14458b4d4600_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"b141b083-dfa5-46fc-bfcc-14458b4d4600_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"b141b083-dfa5-46fc-bfcc-14458b4d4600","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"b141b083-dfa5-46fc-bfcc-14458b4d4600","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"b141b083-dfa5-46fc-bfcc-14458b4d4600","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"1fd1ca8d53313d728a972f5c26156d56d790ab16fd9f0e08090a54249cf5fa7c","readDifferentFirstParty":"abf0396b629f5246c13ba241b10adc68a09109ab42864e9819684388ec3c648b","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"b141b083-dfa5-46fc-bfcc-14458b4d4600","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"b141b083-dfa5-46fc-bfcc-14458b4d4600","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"24ec5cd85fa7a435bdf6b7a57afb4dfa","readDifferentFirstParty":"9644ec10edab637d9c86e6c8881608eb","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_22038700772525033","readDifferentFirstParty":"fake_9138602883120135","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:51:08.920Z","reportedVersion":"6.3212.38","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"firefox","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_1p_js","readDifferentSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_1p","readDifferentSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_1p","readDifferentSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p","readDifferentSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9043591853040591","readDifferentSession":"fake_9043591853040591"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8938904056842567","readDifferentSession":"fake_8938904056842567"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":526,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1365,"desired_max_value":1385},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1365,"desired_max_value":1385},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1365,"desired_max_value":1385}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"b0671ae161c31211808a20265be0e733778d8fbcf862b6b2f12b7e4cd0336c88","readDifferentFirstParty":"63d3f397c98f3b8672e9ad082e1c598ff91b46b8e5af55788e93d408a4bb8a71","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"404b5ae2-bb1e-4ca2-8d42-5a6d0ed22a79","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"f075d437f90796cb3e502ee6bd59557e","readDifferentFirstParty":"4a3dc23769d4cf429da500176844ecd4","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_5380840193918708","readDifferentFirstParty":"fake_2800920348760869","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T05:54:50.908Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"safari","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5625768923083634","readDifferentSession":"fake_696497847780126"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8253295557868257","readDifferentSession":"fake_2839556988268841"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":1428,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":true,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1418,"desired_max_value":1438},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1418,"desired_max_value":1438},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1418,"desired_max_value":1438}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_af338a30-7c33-4bdb-9ac3-4fefb9428bb8","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"e48fa5565dae068c470b8bd3194246476c1e63e97157be9312bac7cc25cb271b","readDifferentFirstParty":"0b3066401b042dcb17fcbf12f6e0cb0fbb2276ea559bb745c1a33a05c60f83fa","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"af338a30-7c33-4bdb-9ac3-4fefb9428bb8","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_50391213847207","readDifferentFirstParty":"fake_8729789295830002","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:01:05.883Z","reportedVersion":"17.2.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"yandex","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"25cb3456-c0f4-4250-b999-26e4a34b5725_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"25cb3456-c0f4-4250-b999-26e4a34b5725_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"25cb3456-c0f4-4250-b999-26e4a34b5725_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"25cb3456-c0f4-4250-b999-26e4a34b5725_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5927841209741347","readDifferentSession":"fake_5577710797486357"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"25cb3456-c0f4-4250-b999-26e4a34b5725_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"25cb3456-c0f4-4250-b999-26e4a34b5725_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"25cb3456-c0f4-4250-b999-26e4a34b5725_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8366279044839668","readDifferentSession":"fake_9066924648092514"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1388,"desired_max_value":1408},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1388,"desired_max_value":1408},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1388,"desired_max_value":1408}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"25cb3456-c0f4-4250-b999-26e4a34b5725","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_25cb3456-c0f4-4250-b999-26e4a34b5725","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"25cb3456-c0f4-4250-b999-26e4a34b5725_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"25cb3456-c0f4-4250-b999-26e4a34b5725_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"25cb3456-c0f4-4250-b999-26e4a34b5725","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"25cb3456-c0f4-4250-b999-26e4a34b5725","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"25cb3456-c0f4-4250-b999-26e4a34b5725","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"623754e2a4a482f7f4e2ea65a03259af92ccc7260678e631fc57d8c3a2c8ed35","readDifferentFirstParty":"d4f5cbf722f79b39cd428b8c5cf52d17ef40e6bf56603767355882c8d0de756d","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"25cb3456-c0f4-4250-b999-26e4a34b5725","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"25cb3456-c0f4-4250-b999-26e4a34b5725","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_5810047419590072","readDifferentFirstParty":"fake_7207365262081475","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:03:58.245Z","reportedVersion":"2401.1.655","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"focus","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"b50e369a-ec1f-4160-9db7-7c87f8169669_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"b50e369a-ec1f-4160-9db7-7c87f8169669_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"b50e369a-ec1f-4160-9db7-7c87f8169669_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_01023606030803248","readDifferentSession":"fake_4124645195882044"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"b50e369a-ec1f-4160-9db7-7c87f8169669_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"b50e369a-ec1f-4160-9db7-7c87f8169669_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9618743481186833","readDifferentSession":"fake_2509089357196932"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":547,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1419,"desired_max_value":1439},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1419,"desired_max_value":1439},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1419,"desired_max_value":1439}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"b50e369a-ec1f-4160-9db7-7c87f8169669","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_b50e369a-ec1f-4160-9db7-7c87f8169669","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"b50e369a-ec1f-4160-9db7-7c87f8169669_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"b50e369a-ec1f-4160-9db7-7c87f8169669_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"b50e369a-ec1f-4160-9db7-7c87f8169669","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"b50e369a-ec1f-4160-9db7-7c87f8169669","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"7be75ab9a067c774c1061135356531f5ea4edf227dae81630db78b8ba90f668a","readDifferentFirstParty":"88f8e4c05efde010c7ad3b1681357b92e8c62fdef0b78aba0f3785e0433c2785","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"b50e369a-ec1f-4160-9db7-7c87f8169669","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"b50e369a-ec1f-4160-9db7-7c87f8169669","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_4393073014621154","readDifferentFirstParty":"fake_4753732301532718","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:08:02.909Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"opera","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"1612657b-ad42-4390-a669-0810ef70f7fa_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"1612657b-ad42-4390-a669-0810ef70f7fa_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"1612657b-ad42-4390-a669-0810ef70f7fa_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"1612657b-ad42-4390-a669-0810ef70f7fa_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_45168042022819277","readDifferentSession":"fake_45168042022819277"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"1612657b-ad42-4390-a669-0810ef70f7fa_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"1612657b-ad42-4390-a669-0810ef70f7fa_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"1612657b-ad42-4390-a669-0810ef70f7fa_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9633299109276772","readDifferentSession":"fake_9633299109276772"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":555,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1440,"desired_max_value":1460},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1440,"desired_max_value":1460},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1440,"desired_max_value":1460}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"1612657b-ad42-4390-a669-0810ef70f7fa","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_1612657b-ad42-4390-a669-0810ef70f7fa","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"1612657b-ad42-4390-a669-0810ef70f7fa_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"1612657b-ad42-4390-a669-0810ef70f7fa_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"1612657b-ad42-4390-a669-0810ef70f7fa","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"1612657b-ad42-4390-a669-0810ef70f7fa","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"1612657b-ad42-4390-a669-0810ef70f7fa","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"30fcdeeedec4cf2984bdf43d7569fc90ffe679200fe82ebe056b3bc79c0252fd","readDifferentFirstParty":"08e5527b3bdca607e5f437c3c66f3625c4369de953679a7d6fb21e02c33b4084","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"1612657b-ad42-4390-a669-0810ef70f7fa","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"1612657b-ad42-4390-a669-0810ef70f7fa","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"af588a4bcd10515c415f3927b4c97173","readDifferentFirstParty":"df5381ddb215f6524c589c6dc7dd37e1","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_5012026239689555","readDifferentFirstParty":"fake_02859808678798692","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:10:45.091Z","reportedVersion":"4.4.2","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"a7d83147-fa82-471f-80a6-2aa4d34ed229_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"a7d83147-fa82-471f-80a6-2aa4d34ed229_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"a7d83147-fa82-471f-80a6-2aa4d34ed229_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"a7d83147-fa82-471f-80a6-2aa4d34ed229_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5854675837798307","readDifferentSession":"fake_5854675837798307"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"a7d83147-fa82-471f-80a6-2aa4d34ed229_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"a7d83147-fa82-471f-80a6-2aa4d34ed229_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"a7d83147-fa82-471f-80a6-2aa4d34ed229_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6100257761827472","readDifferentSession":"fake_6100257761827472"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1435,"desired_max_value":1455},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1435,"desired_max_value":1455},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1435,"desired_max_value":1455}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"a7d83147-fa82-471f-80a6-2aa4d34ed229","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_a7d83147-fa82-471f-80a6-2aa4d34ed229","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"a7d83147-fa82-471f-80a6-2aa4d34ed229_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"a7d83147-fa82-471f-80a6-2aa4d34ed229_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"a7d83147-fa82-471f-80a6-2aa4d34ed229","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"a7d83147-fa82-471f-80a6-2aa4d34ed229","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"a7d83147-fa82-471f-80a6-2aa4d34ed229","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"3120d50b7540b0403c85a5338d9e5f3cb7a1892f7ffaad82debd0f5a1ea0f0ee","readDifferentFirstParty":"befe0107e1b394af0c6c454e728343f10a3ba2591ab02c7a143c7de8a50a1548","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"a7d83147-fa82-471f-80a6-2aa4d34ed229","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"a7d83147-fa82-471f-80a6-2aa4d34ed229","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"ad3def63cc97f1f598eb93f75724226a","readDifferentFirstParty":"2301199224dc412cbf7e77272855f9b3","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_45643114434776644","readDifferentFirstParty":"fake_7476838642720478","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:16:33.630Z","reportedVersion":"121.6167.138","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"edge","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_32804446653966557","readDifferentSession":"fake_32804446653966557"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5123198370413262","readDifferentSession":"fake_5123198370413262"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":561,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1456,"desired_max_value":1476},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1456,"desired_max_value":1476},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1456,"desired_max_value":1476}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"2ff0f646-7e83-484e-8dd0-01417afaf1b6","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_2ff0f646-7e83-484e-8dd0-01417afaf1b6","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"2ff0f646-7e83-484e-8dd0-01417afaf1b6_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"2ff0f646-7e83-484e-8dd0-01417afaf1b6","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"2ff0f646-7e83-484e-8dd0-01417afaf1b6","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"2ff0f646-7e83-484e-8dd0-01417afaf1b6","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"8bdb10c4f204ba8e1b3b9e128a6480a46b25e079f8361ba0303261fee9948e17","readDifferentFirstParty":"5d7e089cee9d8574bf09fc9c5eddc8ba66415c0f229e919692976888e9ce558b","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"2ff0f646-7e83-484e-8dd0-01417afaf1b6","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"2ff0f646-7e83-484e-8dd0-01417afaf1b6","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"52531f70557341159e5eff8a5e866118","readDifferentFirstParty":"74755497451ad81553bf2db28b294c99","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_34084304169253477","readDifferentFirstParty":"fake_02123105340503839","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:19:26.457Z","reportedVersion":"120.2210.150","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"brave","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_37396565345252175","readDifferentSession":"fake_37396565345252175"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_1225688817478181","readDifferentSession":"fake_1225688817478181"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":543,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1409,"desired_max_value":1429},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1409,"desired_max_value":1429},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1409,"desired_max_value":1429}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"9a0255f3-17ae-44f4-83ea-19aed3f220c1","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_9a0255f3-17ae-44f4-83ea-19aed3f220c1","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"9a0255f3-17ae-44f4-83ea-19aed3f220c1_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"9a0255f3-17ae-44f4-83ea-19aed3f220c1","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"9a0255f3-17ae-44f4-83ea-19aed3f220c1","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"9a0255f3-17ae-44f4-83ea-19aed3f220c1","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"2033cddd57dac6143976427d85517f397a5dd239af3eea81cb3f88b5323304bf","readDifferentFirstParty":"df9b47ef513aff02de77f0652043395831a04bcdc0d1fa5cad70b735dc40a699","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"9a0255f3-17ae-44f4-83ea-19aed3f220c1","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"9a0255f3-17ae-44f4-83ea-19aed3f220c1","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bb01c33f008f326f7dde93a3eb00ecf8","readDifferentFirstParty":"88e6a4961fced02fc0bfbf9a9ea50b1d","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_07708856337737169","readDifferentFirstParty":"fake_6773219479147483","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:22:15.218Z","reportedVersion":"1.61.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"duckduckgo","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"681e66ab-2218-4439-bb8a-a5069d5efc96_1p_js","readDifferentSession":"681e66ab-2218-4439-bb8a-a5069d5efc96_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"681e66ab-2218-4439-bb8a-a5069d5efc96_1p","readDifferentSession":"681e66ab-2218-4439-bb8a-a5069d5efc96_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"681e66ab-2218-4439-bb8a-a5069d5efc96_1p","readDifferentSession":"681e66ab-2218-4439-bb8a-a5069d5efc96_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_46341907866684373","readDifferentSession":"fake_46341907866684373"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"681e66ab-2218-4439-bb8a-a5069d5efc96_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"681e66ab-2218-4439-bb8a-a5069d5efc96_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_14986677119508984","readDifferentSession":"fake_14986677119508984"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":546,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1417,"desired_max_value":1437},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1417,"desired_max_value":1437},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1417,"desired_max_value":1437}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"681e66ab-2218-4439-bb8a-a5069d5efc96","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_681e66ab-2218-4439-bb8a-a5069d5efc96","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"681e66ab-2218-4439-bb8a-a5069d5efc96_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"681e66ab-2218-4439-bb8a-a5069d5efc96_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"681e66ab-2218-4439-bb8a-a5069d5efc96","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"681e66ab-2218-4439-bb8a-a5069d5efc96","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"960bbb1bc769d6c3ef798e0a21cc4b1a1541ca4020cf2d978a93397ae06f179e","readDifferentFirstParty":"a8bd801dd69aa53451b42d72a2eb0e842352961e5280598e6370dd690084417a","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"681e66ab-2218-4439-bb8a-a5069d5efc96","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"681e66ab-2218-4439-bb8a-a5069d5efc96","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"2ae3650939b45c24d13678d0e5fe9b37","readDifferentFirstParty":"4b1b6cf0b7f4dcd844d19a1e435ab6f5","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_22575956462713687","readDifferentFirstParty":"fake_7459455380418996","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:27:11.632Z","reportedVersion":"7.104.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"vivaldi","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_0763766820160543","readDifferentSession":"fake_0763766820160543"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6515638986339694","readDifferentSession":"fake_6515638986339694"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":508,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1318,"desired_max_value":1338},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1318,"desired_max_value":1338},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1318,"desired_max_value":1338}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_acfb4065-6a0a-4901-bbd5-4450dc5ff5f7","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"f8fc777a6c5d553d055fd24890bcfbe19e7e2beb2963b2d96abeb6f9b624f816","readDifferentFirstParty":"02b26859b6415ce1ebaa000cff0280ffc679fe9c192197c7ee3ef669d303c0b4","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"acfb4065-6a0a-4901-bbd5-4450dc5ff5f7","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"f3c67ae6de030edc721112472b66adc9","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_07329650678501887","readDifferentFirstParty":"fake_3021868425854537","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:29:56.893Z","reportedVersion":"6.3212.38","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"firefox","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_1p_js","readDifferentSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_1p","readDifferentSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_1p","readDifferentSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p","readDifferentSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9628503434121767","readDifferentSession":"fake_9628503434121767"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"22f433eb-b0b0-4624-8a50-6325dfe12d24_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6751074731808622","readDifferentSession":"fake_6751074731808622"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":526,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1365,"desired_max_value":1385},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1365,"desired_max_value":1385},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1365,"desired_max_value":1385}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"22f433eb-b0b0-4624-8a50-6325dfe12d24","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_22f433eb-b0b0-4624-8a50-6325dfe12d24","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"22f433eb-b0b0-4624-8a50-6325dfe12d24_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"22f433eb-b0b0-4624-8a50-6325dfe12d24_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"22f433eb-b0b0-4624-8a50-6325dfe12d24","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"22f433eb-b0b0-4624-8a50-6325dfe12d24","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"22f433eb-b0b0-4624-8a50-6325dfe12d24","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"2d1ce024cd647cb028267e17c032efd9d6109188fea1640ba6597bc16b4af448","readDifferentFirstParty":"94cf4c1baab666928a4a0dec3e2d48be10ee8831ea77d128b6f3cdb0a97e7091","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"22f433eb-b0b0-4624-8a50-6325dfe12d24","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"22f433eb-b0b0-4624-8a50-6325dfe12d24","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"3df4db63186629fe6cfc77c4a2a8bb4a","readDifferentFirstParty":"e6db8b11832ef982662b435ff5e3013a","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_9155778315358518","readDifferentFirstParty":"fake_22413066526541847","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:33:40.255Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"safari","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"d634fc35-190f-4bc0-a479-6a8eb74670e0_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"d634fc35-190f-4bc0-a479-6a8eb74670e0_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"d634fc35-190f-4bc0-a479-6a8eb74670e0_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_19934782029023257","readDifferentSession":"fake_6817678573931012"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"d634fc35-190f-4bc0-a479-6a8eb74670e0_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"d634fc35-190f-4bc0-a479-6a8eb74670e0_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6962721800616891","readDifferentSession":"fake_8163376235412549"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":1428,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":true,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1418,"desired_max_value":1438},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1418,"desired_max_value":1438},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1418,"desired_max_value":1438}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"d634fc35-190f-4bc0-a479-6a8eb74670e0","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_d634fc35-190f-4bc0-a479-6a8eb74670e0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"d634fc35-190f-4bc0-a479-6a8eb74670e0_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"d634fc35-190f-4bc0-a479-6a8eb74670e0_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"d634fc35-190f-4bc0-a479-6a8eb74670e0","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"d634fc35-190f-4bc0-a479-6a8eb74670e0","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"d061001723bd5266ea7e55ede5465490ee54717c54cf25e7caff9a56b7a3eaa2","readDifferentFirstParty":"12a815a7ec3912ab6babbcb45806fa6f76c4a5620c0ebaedbd9d5fd747811921","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"d634fc35-190f-4bc0-a479-6a8eb74670e0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"d634fc35-190f-4bc0-a479-6a8eb74670e0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_09719076581857689","readDifferentFirstParty":"fake_5911006467900772","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:39:55.422Z","reportedVersion":"17.2.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"yandex","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"39fd8d8f-94a5-480f-8cce-29d531080da3_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"39fd8d8f-94a5-480f-8cce-29d531080da3_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"39fd8d8f-94a5-480f-8cce-29d531080da3_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"39fd8d8f-94a5-480f-8cce-29d531080da3_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9905427229930988","readDifferentSession":"fake_8587891742231117"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"39fd8d8f-94a5-480f-8cce-29d531080da3_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"39fd8d8f-94a5-480f-8cce-29d531080da3_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"39fd8d8f-94a5-480f-8cce-29d531080da3_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9629470674277931","readDifferentSession":"fake_6052956068363453"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1388,"desired_max_value":1408},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1388,"desired_max_value":1408},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1388,"desired_max_value":1408}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"39fd8d8f-94a5-480f-8cce-29d531080da3","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_39fd8d8f-94a5-480f-8cce-29d531080da3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"39fd8d8f-94a5-480f-8cce-29d531080da3_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"39fd8d8f-94a5-480f-8cce-29d531080da3_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"39fd8d8f-94a5-480f-8cce-29d531080da3","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"39fd8d8f-94a5-480f-8cce-29d531080da3","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"39fd8d8f-94a5-480f-8cce-29d531080da3","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"d50155e700642644ff22eea05e108b65e0a7b0deaa8ded693e23c852d46e9d83","readDifferentFirstParty":"9eea8189f364ed31b760498a051b21b438d8b580542df8798f40307623624401","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"39fd8d8f-94a5-480f-8cce-29d531080da3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"39fd8d8f-94a5-480f-8cce-29d531080da3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_9289776314926783","readDifferentFirstParty":"fake_7328784841691762","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:42:46.684Z","reportedVersion":"2401.1.655","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"focus","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"14bda043-cd1d-45c3-bc59-d1674b49d9a3_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"14bda043-cd1d-45c3-bc59-d1674b49d9a3_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"14bda043-cd1d-45c3-bc59-d1674b49d9a3_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9170496894220006","readDifferentSession":"fake_6465094050770603"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"14bda043-cd1d-45c3-bc59-d1674b49d9a3_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"14bda043-cd1d-45c3-bc59-d1674b49d9a3_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_05153839080073985","readDifferentSession":"fake_7223537411155507"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":547,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1419,"desired_max_value":1439},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1419,"desired_max_value":1439},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1419,"desired_max_value":1439}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"14bda043-cd1d-45c3-bc59-d1674b49d9a3","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_14bda043-cd1d-45c3-bc59-d1674b49d9a3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"14bda043-cd1d-45c3-bc59-d1674b49d9a3_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"14bda043-cd1d-45c3-bc59-d1674b49d9a3_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"14bda043-cd1d-45c3-bc59-d1674b49d9a3","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"14bda043-cd1d-45c3-bc59-d1674b49d9a3","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"30e97d219e13ea9ecbbec121d3042423521dc10f059d03599e8cc2eb746299e6","readDifferentFirstParty":"1a000cd66d3b2b36bbbef3022211d49b96ffbb9526d2e9d835eeed6d6c51b854","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"14bda043-cd1d-45c3-bc59-d1674b49d9a3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"14bda043-cd1d-45c3-bc59-d1674b49d9a3","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_48763872137455233","readDifferentFirstParty":"fake_053833929824250726","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:46:53.629Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"opera","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8776396722172586","readDifferentSession":"fake_8776396722172586"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7559913027025027","readDifferentSession":"fake_7559913027025027"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":555,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1440,"desired_max_value":1460},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1440,"desired_max_value":1460},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1440,"desired_max_value":1460}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"53a8063a-bfdc-42cc-b24d-f18f813d26fb","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_53a8063a-bfdc-42cc-b24d-f18f813d26fb","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"53a8063a-bfdc-42cc-b24d-f18f813d26fb_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"53a8063a-bfdc-42cc-b24d-f18f813d26fb","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"53a8063a-bfdc-42cc-b24d-f18f813d26fb","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"53a8063a-bfdc-42cc-b24d-f18f813d26fb","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"8051ee00ff5e674ae2de4f34fad8b4fbfaf0a622f4e89ae6fbe6bbe3381c0682","readDifferentFirstParty":"03bfcb39222d362512f65979bf945c23e19ec421c03fbb90bfc642a4437b300b","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"53a8063a-bfdc-42cc-b24d-f18f813d26fb","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"53a8063a-bfdc-42cc-b24d-f18f813d26fb","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"d34fa371cef3a463b5b7e98e49433e87","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_7963912558909954","readDifferentFirstParty":"fake_9441363953258415","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:49:36.591Z","reportedVersion":"4.4.2","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"0f2aa2e1-c708-4569-bfaa-890b62d34321_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"0f2aa2e1-c708-4569-bfaa-890b62d34321_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"0f2aa2e1-c708-4569-bfaa-890b62d34321_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"0f2aa2e1-c708-4569-bfaa-890b62d34321_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7726949806957972","readDifferentSession":"fake_7726949806957972"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"0f2aa2e1-c708-4569-bfaa-890b62d34321_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"0f2aa2e1-c708-4569-bfaa-890b62d34321_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"0f2aa2e1-c708-4569-bfaa-890b62d34321_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_49832788377687876","readDifferentSession":"fake_49832788377687876"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1435,"desired_max_value":1455},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1435,"desired_max_value":1455},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1435,"desired_max_value":1455}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"0f2aa2e1-c708-4569-bfaa-890b62d34321","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_0f2aa2e1-c708-4569-bfaa-890b62d34321","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"0f2aa2e1-c708-4569-bfaa-890b62d34321_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"0f2aa2e1-c708-4569-bfaa-890b62d34321_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"0f2aa2e1-c708-4569-bfaa-890b62d34321","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"0f2aa2e1-c708-4569-bfaa-890b62d34321","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"0f2aa2e1-c708-4569-bfaa-890b62d34321","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"fc5c03f98f87a1b2e2728ddc23d8b8eb3289b8ce29bbee1e2548a919b15aa3b2","readDifferentFirstParty":"b423a45f6469508bbe5b34af9b9a341b9ddece9acb47c7753393d0ce25e0af6a","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"0f2aa2e1-c708-4569-bfaa-890b62d34321","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"0f2aa2e1-c708-4569-bfaa-890b62d34321","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"88bf9cc4e592a89504f16afaed0e798d","readDifferentFirstParty":"7d4a15566ef3545f950ddc73e255014a","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_06270870440749077","readDifferentFirstParty":"fake_5404628454009488","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:55:37.668Z","reportedVersion":"121.6167.138","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"edge","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8822565636962671","readDifferentSession":"fake_8822565636962671"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_11085135034025906","readDifferentSession":"fake_11085135034025906"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":561,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1456,"desired_max_value":1476},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1456,"desired_max_value":1476},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1456,"desired_max_value":1476}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"ca13c5b9-7e2e-4891-9961-f362ef1280d2","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_ca13c5b9-7e2e-4891-9961-f362ef1280d2","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"ca13c5b9-7e2e-4891-9961-f362ef1280d2_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"ca13c5b9-7e2e-4891-9961-f362ef1280d2","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"ca13c5b9-7e2e-4891-9961-f362ef1280d2","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"ca13c5b9-7e2e-4891-9961-f362ef1280d2","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"f6fb2e2f972ce7e90a5f16989e71b5d916048e1cffbe65eb7fcad98c744e4422","readDifferentFirstParty":"8a4f17f38edcc095ba47d6b875014d50cc37975b71384e0e3b1aba5b578d4a59","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"ca13c5b9-7e2e-4891-9961-f362ef1280d2","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"ca13c5b9-7e2e-4891-9961-f362ef1280d2","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"e972e0d39862e93f18639e263b41a635","readDifferentFirstParty":"85bac9af915d4f63aff3efb6c732ebc0","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_16497107645353304","readDifferentFirstParty":"fake_1411140509449702","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T06:58:28.787Z","reportedVersion":"120.2210.150","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"brave","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_4596277179296391","readDifferentSession":"fake_4596277179296391"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5698487311494467","readDifferentSession":"fake_5698487311494467"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":543,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1409,"desired_max_value":1429},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1409,"desired_max_value":1429},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1409,"desired_max_value":1429}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"90fa2b7ca859085370b0650793c0c9b3aacc5387573d3a455084e7c4029c221c","readDifferentFirstParty":"032a3e9066c54e21362cabe981bb840b7f4dfac24f842a66bc30e9bd47cc46a4","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"b41dd6b3-3839-4e3a-a0a5-73ada9f2c87c","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"c5b661d572d9fb33a250eed250be3c12","readDifferentFirstParty":"317afe0e1e684a3677365c2359a8981a","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_2330561978241681","readDifferentFirstParty":"fake_3547244344395113","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:01:22.467Z","reportedVersion":"1.61.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"duckduckgo","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"bc619c2c-54ef-40a1-803f-62fe80086e66_1p_js","readDifferentSession":"bc619c2c-54ef-40a1-803f-62fe80086e66_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bc619c2c-54ef-40a1-803f-62fe80086e66_1p","readDifferentSession":"bc619c2c-54ef-40a1-803f-62fe80086e66_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bc619c2c-54ef-40a1-803f-62fe80086e66_1p","readDifferentSession":"bc619c2c-54ef-40a1-803f-62fe80086e66_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5587040628217874","readDifferentSession":"fake_5587040628217874"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bc619c2c-54ef-40a1-803f-62fe80086e66_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bc619c2c-54ef-40a1-803f-62fe80086e66_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5437539715020361","readDifferentSession":"fake_5437539715020361"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":546,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1417,"desired_max_value":1437},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1417,"desired_max_value":1437},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1417,"desired_max_value":1437}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"bc619c2c-54ef-40a1-803f-62fe80086e66","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_bc619c2c-54ef-40a1-803f-62fe80086e66","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"bc619c2c-54ef-40a1-803f-62fe80086e66_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"bc619c2c-54ef-40a1-803f-62fe80086e66_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"bc619c2c-54ef-40a1-803f-62fe80086e66","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"bc619c2c-54ef-40a1-803f-62fe80086e66","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"5056585dac5fe0ad6281842176174ae73d7b444843251921a4b6c4bd57a8945f","readDifferentFirstParty":"166abd7b8867bf5c98813b57263870cb517dd1dc10f5d1d13d2ceca0881cc479","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bc619c2c-54ef-40a1-803f-62fe80086e66","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"bc619c2c-54ef-40a1-803f-62fe80086e66","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"ca922119609075079a66fd1bd63b3a43","readDifferentFirstParty":"0ca6ce6cc80c743ce868b851a224aefe","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_7314563184890583","readDifferentFirstParty":"fake_6044103235835423","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:06:17.981Z","reportedVersion":"7.104.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"vivaldi","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"9f753a04-6e84-45ba-b6d4-93bbda61703b_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"9f753a04-6e84-45ba-b6d4-93bbda61703b_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"9f753a04-6e84-45ba-b6d4-93bbda61703b_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"9f753a04-6e84-45ba-b6d4-93bbda61703b_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7170368825973801","readDifferentSession":"fake_7170368825973801"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"9f753a04-6e84-45ba-b6d4-93bbda61703b_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"9f753a04-6e84-45ba-b6d4-93bbda61703b_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"9f753a04-6e84-45ba-b6d4-93bbda61703b_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_47389797524995636","readDifferentSession":"fake_47389797524995636"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":508,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1318,"desired_max_value":1338},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1318,"desired_max_value":1338},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1318,"desired_max_value":1338}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"9f753a04-6e84-45ba-b6d4-93bbda61703b","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_9f753a04-6e84-45ba-b6d4-93bbda61703b","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"9f753a04-6e84-45ba-b6d4-93bbda61703b_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"9f753a04-6e84-45ba-b6d4-93bbda61703b_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"9f753a04-6e84-45ba-b6d4-93bbda61703b","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"9f753a04-6e84-45ba-b6d4-93bbda61703b","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"9f753a04-6e84-45ba-b6d4-93bbda61703b","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"a90e46dc46cb3ecc69b7c2784aaccf3ec5ed62250546075965e4f9af5769fdfd","readDifferentFirstParty":"f37d79c52d5d22098da4df6434f5d4b3f3bfc0a1a8eab7e0e38f8af2cf23a96d","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"9f753a04-6e84-45ba-b6d4-93bbda61703b","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"9f753a04-6e84-45ba-b6d4-93bbda61703b","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"90436ce04edbd9841be3d7ce161c6706","readDifferentFirstParty":"c6fbffbd7e94b74f8f439643d73a3aa3","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_737025287832634","readDifferentFirstParty":"fake_6998926687154137","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:09:05.109Z","reportedVersion":"6.3212.38","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"firefox","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_1p_js","readDifferentSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_1p","readDifferentSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_1p","readDifferentSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p","readDifferentSession":"a133d7c3-635f-4331-b3c2-18ba1a92778b_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_570392655081654","readDifferentSession":"fake_570392655081654"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_2600586773235809","readDifferentSession":"fake_2600586773235809"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":526,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1365,"desired_max_value":1385},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1365,"desired_max_value":1385},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1365,"desired_max_value":1385}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"0174c0ca-9aa4-40af-9270-5f0f41727f1f","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_0174c0ca-9aa4-40af-9270-5f0f41727f1f","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"0174c0ca-9aa4-40af-9270-5f0f41727f1f_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"0174c0ca-9aa4-40af-9270-5f0f41727f1f","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"0174c0ca-9aa4-40af-9270-5f0f41727f1f","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"0174c0ca-9aa4-40af-9270-5f0f41727f1f","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"d9262a7ea5b1c4ea110ec7e3ce0edf399c369ccb84ea61b64cfaa623ec6c6f07","readDifferentFirstParty":"371e75ef0490571429a4378d77ff9c8e9a7b8165e4e58bc5eaebb0b06aae4bf0","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"0174c0ca-9aa4-40af-9270-5f0f41727f1f","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"0174c0ca-9aa4-40af-9270-5f0f41727f1f","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"6554f3353349fa98520c67a42b4223fd","readDifferentFirstParty":"fed9928c6ed68299719c7f97f5d0d9f7","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_9757713370326149","readDifferentFirstParty":"fake_9464611253802231","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:12:48.473Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"safari","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"db36035c-6dea-447e-85bd-6e0d584e4dc0_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"db36035c-6dea-447e-85bd-6e0d584e4dc0_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"db36035c-6dea-447e-85bd-6e0d584e4dc0_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9354111922429853","readDifferentSession":"fake_5420471615030615"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"db36035c-6dea-447e-85bd-6e0d584e4dc0_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"db36035c-6dea-447e-85bd-6e0d584e4dc0_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8213378012957586","readDifferentSession":"fake_2595384713588973"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":1428,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":true,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1418,"desired_max_value":1438},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1418,"desired_max_value":1438},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1418,"desired_max_value":1438}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"db36035c-6dea-447e-85bd-6e0d584e4dc0","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_db36035c-6dea-447e-85bd-6e0d584e4dc0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"db36035c-6dea-447e-85bd-6e0d584e4dc0_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"db36035c-6dea-447e-85bd-6e0d584e4dc0_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"db36035c-6dea-447e-85bd-6e0d584e4dc0","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"db36035c-6dea-447e-85bd-6e0d584e4dc0","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"8132da34b59051bbf21b6ad52a18308ea5f70d6386aacd32bd699ac9804143c1","readDifferentFirstParty":"8e5616ba8320a6ab6361b3b6f236eabbd663373b3b13ab57915cd1353c555133","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"db36035c-6dea-447e-85bd-6e0d584e4dc0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"db36035c-6dea-447e-85bd-6e0d584e4dc0","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_9413648602277178","readDifferentFirstParty":"fake_22770160281843355","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:19:03.645Z","reportedVersion":"17.2.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"yandex","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"49607ecd-3ee8-4a44-bd8e-c244da323869_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"49607ecd-3ee8-4a44-bd8e-c244da323869_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"49607ecd-3ee8-4a44-bd8e-c244da323869_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"49607ecd-3ee8-4a44-bd8e-c244da323869_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5932882158415462","readDifferentSession":"fake_9192396550472697"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"49607ecd-3ee8-4a44-bd8e-c244da323869_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"49607ecd-3ee8-4a44-bd8e-c244da323869_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"49607ecd-3ee8-4a44-bd8e-c244da323869_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9207965289512603","readDifferentSession":"fake_38861359616020485"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1388,"desired_max_value":1408},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1388,"desired_max_value":1408},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1388,"desired_max_value":1408}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"49607ecd-3ee8-4a44-bd8e-c244da323869","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_49607ecd-3ee8-4a44-bd8e-c244da323869","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"49607ecd-3ee8-4a44-bd8e-c244da323869_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"49607ecd-3ee8-4a44-bd8e-c244da323869_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"49607ecd-3ee8-4a44-bd8e-c244da323869","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"49607ecd-3ee8-4a44-bd8e-c244da323869","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"49607ecd-3ee8-4a44-bd8e-c244da323869","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"09d6e4ecd8635ccdeb90a30b51a9d183406b2bd0dc9ea6dfd4a9a227bfcb14dd","readDifferentFirstParty":"bee3f40690762d29a1356d4e7128fb2cd39db1ad17a7993fe69a4978971bbc96","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"49607ecd-3ee8-4a44-bd8e-c244da323869","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"49607ecd-3ee8-4a44-bd8e-c244da323869","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_6257259754309454","readDifferentFirstParty":"fake_9435717451728698","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:21:56.686Z","reportedVersion":"2401.1.655","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"focus","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"3ec11668-e680-4c8e-b3e9-503c42138114_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"3ec11668-e680-4c8e-b3e9-503c42138114_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"3ec11668-e680-4c8e-b3e9-503c42138114_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_28354997905348145","readDifferentSession":"fake_6409666099257618"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"3ec11668-e680-4c8e-b3e9-503c42138114_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"3ec11668-e680-4c8e-b3e9-503c42138114_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"2","readDifferentSession":"3"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_15019625044274054","readDifferentSession":"fake_30166806461023254"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":547,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1419,"desired_max_value":1439},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1419,"desired_max_value":1439},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1419,"desired_max_value":1439}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"3ec11668-e680-4c8e-b3e9-503c42138114","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_3ec11668-e680-4c8e-b3e9-503c42138114","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"3ec11668-e680-4c8e-b3e9-503c42138114_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"3ec11668-e680-4c8e-b3e9-503c42138114_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"3ec11668-e680-4c8e-b3e9-503c42138114","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"3ec11668-e680-4c8e-b3e9-503c42138114","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","testFailed":true,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"a220f925d0518dacc406a295a5cced8fac42725c7d14e0446f00037d4a6a242e","readDifferentFirstParty":"5cb1638bd00c18868be0d69c97eb0e1c9bbd8b8a1f75a35d8ce7773fa157c1be","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"3ec11668-e680-4c8e-b3e9-503c42138114","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"3ec11668-e680-4c8e-b3e9-503c42138114","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_9706468738097604","readDifferentFirstParty":"fake_27984294424939815","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:26:01.508Z","reportedVersion":"122.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"opera","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"8f6873fe-716b-4b99-8693-ca4a0cf94587_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"8f6873fe-716b-4b99-8693-ca4a0cf94587_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"8f6873fe-716b-4b99-8693-ca4a0cf94587_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"8f6873fe-716b-4b99-8693-ca4a0cf94587_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7606743552795265","readDifferentSession":"fake_7606743552795265"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"8f6873fe-716b-4b99-8693-ca4a0cf94587_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"8f6873fe-716b-4b99-8693-ca4a0cf94587_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"8f6873fe-716b-4b99-8693-ca4a0cf94587_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_49393019158369866","readDifferentSession":"fake_49393019158369866"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":555,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1440,"desired_max_value":1460},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1440,"desired_max_value":1460},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1440,"desired_max_value":1460}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"8f6873fe-716b-4b99-8693-ca4a0cf94587","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_8f6873fe-716b-4b99-8693-ca4a0cf94587","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"8f6873fe-716b-4b99-8693-ca4a0cf94587_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"8f6873fe-716b-4b99-8693-ca4a0cf94587_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"8f6873fe-716b-4b99-8693-ca4a0cf94587","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"8f6873fe-716b-4b99-8693-ca4a0cf94587","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"8f6873fe-716b-4b99-8693-ca4a0cf94587","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"ddb35eb9cdc3c9c3b13c1138feb113d648f7e91357447a3db529c917965fc365","readDifferentFirstParty":"86d248d91a6c4c989c7ce1a0d36884963c46ff5f52daa4b3ec861c7be437dc71","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"8f6873fe-716b-4b99-8693-ca4a0cf94587","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"8f6873fe-716b-4b99-8693-ca4a0cf94587","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"149f08b78d56d10418999d7d55753427","readDifferentFirstParty":"5695c378fbd1834895dfa3b56bfe45ab","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_8880536809380877","readDifferentFirstParty":"fake_22218761408031829","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:28:44.919Z","reportedVersion":"4.4.2","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"571e47ac-b9ae-494f-aacb-230b33494d44_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"571e47ac-b9ae-494f-aacb-230b33494d44_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"571e47ac-b9ae-494f-aacb-230b33494d44_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"571e47ac-b9ae-494f-aacb-230b33494d44_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_1609568771788934","readDifferentSession":"fake_1609568771788934"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"571e47ac-b9ae-494f-aacb-230b33494d44_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"571e47ac-b9ae-494f-aacb-230b33494d44_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"571e47ac-b9ae-494f-aacb-230b33494d44_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_20342146588738763","readDifferentSession":"fake_20342146588738763"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1435,"desired_max_value":1455},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1435,"desired_max_value":1455},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1435,"desired_max_value":1455}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"571e47ac-b9ae-494f-aacb-230b33494d44","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_571e47ac-b9ae-494f-aacb-230b33494d44","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"571e47ac-b9ae-494f-aacb-230b33494d44_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"571e47ac-b9ae-494f-aacb-230b33494d44_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"571e47ac-b9ae-494f-aacb-230b33494d44","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"571e47ac-b9ae-494f-aacb-230b33494d44","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"571e47ac-b9ae-494f-aacb-230b33494d44","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"ab4a5d99584aa5d334bf0b8fe5a2d53bc755ba283bd8e7e3bad8362def8792fd","readDifferentFirstParty":"8a9229f0bd641fbd9fe3638e0db09260d7d35e50752c7936f383709d200edbb3","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"571e47ac-b9ae-494f-aacb-230b33494d44","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"571e47ac-b9ae-494f-aacb-230b33494d44","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"5bb2e8866793085573dcecdd9cb6bbf3","readDifferentFirstParty":"3876dba3ce6b051dbd0e589dab7169f3","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_44094218551478637","readDifferentFirstParty":"fake_5777381210533414","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:34:19.948Z","reportedVersion":"121.6167.138","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"edge","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"6a76dc40-7b0d-4231-9f66-bab617c4209e_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"6a76dc40-7b0d-4231-9f66-bab617c4209e_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"6a76dc40-7b0d-4231-9f66-bab617c4209e_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"6a76dc40-7b0d-4231-9f66-bab617c4209e_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7902710519114162","readDifferentSession":"fake_7902710519114162"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"6a76dc40-7b0d-4231-9f66-bab617c4209e_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"6a76dc40-7b0d-4231-9f66-bab617c4209e_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"6a76dc40-7b0d-4231-9f66-bab617c4209e_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_28464241877567176","readDifferentSession":"fake_28464241877567176"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":561,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1456,"desired_max_value":1476},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1456,"desired_max_value":1476},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1456,"desired_max_value":1476}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"6a76dc40-7b0d-4231-9f66-bab617c4209e","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_6a76dc40-7b0d-4231-9f66-bab617c4209e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"6a76dc40-7b0d-4231-9f66-bab617c4209e_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"6a76dc40-7b0d-4231-9f66-bab617c4209e_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"6a76dc40-7b0d-4231-9f66-bab617c4209e","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"6a76dc40-7b0d-4231-9f66-bab617c4209e","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"6a76dc40-7b0d-4231-9f66-bab617c4209e","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"9b64af5e1e02311f21fece2d21cb9f9d537b04d47b14129edbecf5d0d75e48a9","readDifferentFirstParty":"3e5e932bae0e3f2b20ddfc178acf2ee28434d8ec552bb04ca02be52049e2efdf","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"6a76dc40-7b0d-4231-9f66-bab617c4209e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"6a76dc40-7b0d-4231-9f66-bab617c4209e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"45f3075c263c0660687dd2b333ecbfe2","readDifferentFirstParty":"6f57370391ff55ae4b70a2e9bf9094d6","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_7373250102759723","readDifferentFirstParty":"fake_502153180579952","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:37:12.365Z","reportedVersion":"120.2210.150","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"brave","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6902785780019751","readDifferentSession":"fake_6902785780019751"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_33950059611712113","readDifferentSession":"fake_33950059611712113"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"passed":true,"description":"Microsoft Click ID"},"mc_eid":{"passed":true,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"passed":true,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"passed":true,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"passed":true,"description":"Omeda marketing 'known' customer id"},"_openstat":{"passed":true,"description":"Yandex tracking parameter"},"vero_conv":{"passed":true,"description":"Vero tracking parameter"},"vero_id":{"passed":true,"description":"Vero tracking parameter"},"wickedid":{"passed":true,"description":"Wicked Reports e-commerce tracking"},"yclid":{"passed":true,"description":"Yandex Click ID"},"__s":{"passed":true,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"passed":true,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"passed":true,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"passed":true,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"passed":true,"description":"MailerLite email tracking"},"_hsenc":{"passed":true,"description":"HubSpot tracking parameter"},"__hssc":{"passed":true,"description":"HubSpot tracking parameter"},"__hstc":{"passed":true,"description":"HubSpot tracking parameter"},"__hsfp":{"passed":true,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"passed":true,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":543,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1409,"desired_max_value":1429},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1409,"desired_max_value":1429},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1409,"desired_max_value":1429}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"746ebf45-47c6-4141-ade2-c5fc3a2b414e","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_746ebf45-47c6-4141-ade2-c5fc3a2b414e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"746ebf45-47c6-4141-ade2-c5fc3a2b414e_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"746ebf45-47c6-4141-ade2-c5fc3a2b414e","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"746ebf45-47c6-4141-ade2-c5fc3a2b414e","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"746ebf45-47c6-4141-ade2-c5fc3a2b414e","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"807f8d13a53137b1ba569470daaae13bfce5f92db2b9e3b4153d07584b796b15","readDifferentFirstParty":"d686f1eebf6c3d74cff35242afec431c980bccb19b0229ab4866d8da128d7a68","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"746ebf45-47c6-4141-ade2-c5fc3a2b414e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"746ebf45-47c6-4141-ade2-c5fc3a2b414e","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"f954cf65ac0cb1f631f0ece524c045a9","readDifferentFirstParty":"d5be3b40589e9d68bd4846e0f7eb16dd","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_21235814406175124","readDifferentFirstParty":"fake_46811518859768064","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:39:56.559Z","reportedVersion":"1.61.1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"duckduckgo","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_1p_js","readDifferentSession":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_1p_js"},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_1p","readDifferentSession":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_1p","readDifferentSession":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_1p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_04761307486099087","readDifferentSession":"fake_04761307486099087"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p","readDifferentSession":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed_3p"},"favicon cache":{"unsupported":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_06384102341824627","readDifferentSession":"fake_06384102341824627"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"passed":true,"description":"Facebook Click Identifier"},"gclid":{"passed":true,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"passed":true,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":false,"result":"loaded insecurely","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":546,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1417,"desired_max_value":1437},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1417,"desired_max_value":1437},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1417,"desired_max_value":1437}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"ffd82839-0111-4ea8-a1c0-b283c9602bf9","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_ffd82839-0111-4ea8-a1c0-b283c9602bf9","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"ffd82839-0111-4ea8-a1c0-b283c9602bf9_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"ffd82839-0111-4ea8-a1c0-b283c9602bf9","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"ffd82839-0111-4ea8-a1c0-b283c9602bf9","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"c846cb44-12d2-41b3-b2a6-38ca1a4518ed","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"e9d1786087a806addb9fb761641e4502d78cec72bf2dd93adfce050f8038eeaf","readDifferentFirstParty":"0855efbf01d8cca6d9413ab2195f7bb98598987fbd15f98f4004bbdb72c93675","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"ffd82839-0111-4ea8-a1c0-b283c9602bf9","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"ffd82839-0111-4ea8-a1c0-b283c9602bf9","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"c3f72af61952749ec5dbe175f2891bd3","readDifferentFirstParty":"0b031d72cfdaafdbdd59ebce1720a4ba","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_03258735435842386","readDifferentFirstParty":"fake_6204755420238066","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":true,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:44:51.418Z","reportedVersion":"7.104.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"vivaldi","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7057099800439497","readDifferentSession":"fake_7057099800439497"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Web SQL Database":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","description":"The Web SQL Database is a deprecated web API for storing data in an SQL database.","readSameSession":"Error: Web SQL is deprecated","readDifferentSession":"Error: Web SQL is deprecated"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_2817619883592213","readDifferentSession":"fake_2817619883592213"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h3"}},"misc":{"Tor enabled":{"IsTorExit":false,"passed":false,"description":"The Tor network sends the browser's web requests through a series of relays to hide a user's IP address, thereby helping to mask their identity and location. This test checks to see if the Tor network is being used by default."},"GPC enabled third-party":{"passed":false,"description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a visited website not to sell the user's personal data to other parties. This test checks to see if the GPC header is sent to third-party elements on the web page."},"ECH enabled":{"SNI_status":"plaintext","passed":false,"description":"Encrypted Client Hello (ECH) is a new protocol that hides the website you are visiting from third-party network eavesdroppers."},"Stream isolation":{"write":"() => {\n      if (!usingTor) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (usingTor) {\n        return ipAddress;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"Browsers that use Tor can use a different Tor circuit per top-level website."},"IP address leak":{"description":"IP addresses can be used to uniquely identify a large percentage of users. A proxy, VPN, or Tor can mask a user's IP address.","passed":false},"GPC enabled first-party":{"header value":"undefined","description":"The Global Privacy Control is an HTTP header that can be sent by a browser to instruct a website not to sell the user's personal data to third parties. This test checks to see if the GPC header is sent by default to the top-level website.","passed":false}},"query":{"fbclid":{"value":"8303910894658098","passed":false,"description":"Facebook Click Identifier"},"gclid":{"value":"8303910894658098","passed":false,"description":"Google Click Identifier"},"msclkid":{"value":"8303910894658098","passed":false,"description":"Microsoft Click ID"},"mc_eid":{"value":"8303910894658098","passed":false,"description":"Mailchimp Email ID (email recipient's address)"},"dclid":{"value":"8303910894658098","passed":false,"description":"DoubleClick Click ID (Google)"},"oly_anon_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'anonymous' customer id"},"oly_enc_id":{"value":"8303910894658098","passed":false,"description":"Omeda marketing 'known' customer id"},"_openstat":{"value":"8303910894658098","passed":false,"description":"Yandex tracking parameter"},"vero_conv":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"vero_id":{"value":"8303910894658098","passed":false,"description":"Vero tracking parameter"},"wickedid":{"value":"8303910894658098","passed":false,"description":"Wicked Reports e-commerce tracking"},"yclid":{"value":"8303910894658098","passed":false,"description":"Yandex Click ID"},"__s":{"value":"8303910894658098","passed":false,"description":"Drip.com email address tracking parameter"},"rb_clickid":{"value":"8303910894658098","passed":false,"description":"Unknown high-entropy tracking parameter"},"s_cid":{"value":"8303910894658098","passed":false,"description":"Adobe Site Catalyst tracking parameter"},"ml_subscriber":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"ml_subscriber_hash":{"value":"8303910894658098","passed":false,"description":"MailerLite email tracking"},"_hsenc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hssc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hstc":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"__hsfp":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"hsCtaTracking":{"value":"8303910894658098","passed":false,"description":"HubSpot tracking parameter"},"mkt_tok":{"value":"8303910894658098","passed":false,"description":"Adobe Marketo tracking parameter"}},"https":{"Upgradable image":{"passed":true,"result":"upgraded","description":"Checks to see if the browser attempts to upgrade an insecure address for an image to HTTPS whenever possible."},"Upgradable script":{"passed":true,"result":"blocked","description":"Checks to see if the browser attempts to upgrade an insecure address for an script to HTTPS whenever possible."},"Upgradable hyperlink":{"upgraded":false,"passed":false,"description":"Checks to see if the user has clicked on a hyperlink to an insecure address, if the browser upgrades that address to HTTPS whenever possible."},"Upgradable address":{"upgraded":false,"passed":false,"description":"Checks to see if an insecure address entered into the browser's address bar is upgraded to HTTPS whenever possible."},"Insecure website warning":{"passed":false,"result":"Insecure website loaded","description":"Checks to see if the browser stops loading an insecure website and warns the user before giving them the option to continue. Known as HTTPS-Only Mode in some browsers."}},"fingerprinting":{"screenX":{"expression":"screenX","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the left edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"screenY":{"expression":"screenY","actual_value":0,"desired_min":0,"desired_max":10,"passed":true,"description":"Position, in pixels, of the top edge of the browser window on screen.","desired_min_value":0,"desired_max_value":10},"outerHeight":{"expression":"outerHeight","actual_value":508,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the browser window in pixels, including browser chrome.","desired_min_value":1318,"desired_max_value":1338},"screen.width":{"expression":"screen.width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen, in pixels.","desired_min_value":970,"desired_max_value":990},"screen.height":{"expression":"screen.height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen, in pixels.","desired_min_value":1318,"desired_max_value":1338},"Media query screen width":{"name":"Media query screen width","actual_value":375,"desired_min":"innerWidth - 10","desired_max":"innerWidth + 10","passed":false,"description":"Width of the user's screen in pixels.","desired_min_value":970,"desired_max_value":990},"Media query screen height":{"name":"Media query screen height","actual_value":667,"desired_min":"innerHeight - 10","desired_max":"innerHeight + 10","passed":false,"description":"Height of the user's screen in pixels.","desired_min_value":1318,"desired_max_value":1338}},"navigation":{"sessionStorage":{"write":"(secret) => sessionStorage.setItem(\"secret\", secret)","read":"() => sessionStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The sessionStorage API is similar to the localStorage API, but it does not persist across tabs or across browser sessions. Nonetheless, it can be used to track users if they navigate from one website to another. This tracking can be thwarted by partitioning sessionStorage between websites."},"window.name":{"write":"(secret) => window.name = \"name_\" + secret","read":"() => window.name","unsupported":false,"readSameFirstParty":"name_047ccb95-eb4e-4563-8a9b-8f11806c6b4c","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"The window.name API allows websites to store data that will persist after the user has navigated the tab to a different website. This mechanism could be partitioned so that data is not allowed to persist between websites."},"document.referrer":{"write":"(secret) => { /* do nothing */ }","read":"() => document.referrer","unsupported":false,"readSameFirstParty":"https://test-pages.privacytests2.org/","readDifferentFirstParty":"https://test-pages.privacytests2.org/","passed":false,"testFailed":false,"description":"The Referer [sic] request header is a mechanism used by browsers to let a website know where the user is visiting from. This header is inherently tracking users across websites. In recent times, browsers have switched to a policy of trimming a referrer to convey less tracking information, but Referer continues to convey cross-site tracking data by default."}},"supercookies":{"cookie (JS)":{"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","unsupported":false,"readSameFirstParty":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_js","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"cookie (HTTP)":{"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","unsupported":false,"readSameFirstParty":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c_http","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them."},"localStorage":{"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","unsupported":false,"readSameFirstParty":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c","readDifferentFirstParty":null,"passed":true,"testFailed":false,"description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites."},"indexedDB":{"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","unsupported":false,"readSameFirstParty":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c","passed":true,"testFailed":false,"description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned."},"SharedWorker":{"write":"async (secret) => {\n      try {\n        let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n        worker.port.start();\n//        console.log(\"worker\", worker);\n        const messagePromise = new Promise((resolve) => {\n          worker.port.onmessage = (e) => resolve(e.data);\n        });\n        worker.port.postMessage(secret);\n        await messagePromise;\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let worker = new SharedWorker(\"supercookies_sharedworker.js\");\n      worker.port.start();\n      const messagePromise = new Promise((resolve, reject) => {\n        worker.port.onmessage = (e) => resolve(e.data);\n        setTimeout(() => reject(new Error(\"no SharedWorker message received\")), 200);\n      });\n      worker.port.postMessage(\"request\");\n      const message = await messagePromise;\n      if (message === \"none\") {\n        throw new Error(\"Unsupported\");\n      }\n      return message;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The SharedWorker API allows scripts from multiple tabs to share a background thread of computation. If SharedWorker is not partitioned, then it can be abused to shared data between websites in your browser."},"blob":{"write":"(secret) => {\n      try {\n        let blobURL = URL.createObjectURL(new Blob([secret]));\n        fetch(`${baseURI}blob?mode=write&key=${secret}&blobUrl=${encodeURIComponent(blobURL)}`);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async (secret) => {\n      let response = await fetch(`${baseURI}blob?mode=read&key=${secret}`);\n      let result = await response.json();\n      let blobUrl = decodeURIComponent(result.blobUrl);\n      let blobResponse = await fetch(blobUrl);\n      return blobResponse.text();\n    }","unsupported":false,"readSameFirstParty":"Error: Load failed","readDifferentFirstParty":"Error: Load failed","testFailed":true,"description":"A 'blob URL' is a local reference to some raw data. Trackers can use a blob URL to share data between websites."},"BroadcastChannel":{"write":"(secret) => {\n      try {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data === \"request\") {\n            bc.postMessage(secret);\n          }\n        };\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() =>\n      new Promise((resolve, reject) => {\n        let bc = new BroadcastChannel(\"secrets\");\n        bc.onmessage = (event) => {\n          if (event.data !== \"request\") {\n            resolve(event.data);\n          }\n        };\n        bc.postMessage(\"request\");\n        setTimeout(() => reject({message: \"no BroadcastChannel message\"}), 3000);\n      })","unsupported":false,"readSameFirstParty":"Error: no BroadcastChannel message","readDifferentFirstParty":"Error: no BroadcastChannel message","testFailed":true,"description":"A BroadcastChannel is designed to send messages between tabs. In some browsers it can be used for cross-site communication and tracking."},"fetch cache":{"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking."},"XMLHttpRequest cache":{"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack."},"iframe cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"2","passed":true,"testFailed":false,"description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking."},"CacheStorage":{"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","unsupported":false,"readSameFirstParty":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')","passed":true,"testFailed":false,"description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users."},"favicon cache":{"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","unsupported":false,"readSameFirstParty":"1","readDifferentFirstParty":"1","passed":false,"testFailed":false,"description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites."},"locks":{"write":"async (key) => {\n      if (navigator.locks) {\n        navigator.locks.request(key, lock => new Promise((f,r) => {}));\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].clientId;\n      } else {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      if (navigator.locks) {\n        let queryResult = await navigator.locks.query();\n        return queryResult.held[0].name;\n      }\n    }","unsupported":false,"readSameFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","readDifferentFirstParty":"Error: undefined is not an object (evaluating 'queryResult.held[0].name')","testFailed":true,"description":"navigator.locks (only supported in some browsers) allows scripts on multiple tabs to coordinate. If this API is not partitioned, it can be used for cross-site tracking."},"TLS Session ID":{"write":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","read":"async () => {\n      let results = await fetch(\"https://tls.privacytests2.org:8900/\");\n      return (await results.json()).sessionId;\n    }","unsupported":false,"readSameFirstParty":"ce07f641617c2283950a490cbbc26b919b65297ac9386d3a128b5ff7b8d0f34d","readDifferentFirstParty":"a79a877d66ea24f6dc629f944ed0d79241d5280fad6f5c1e46d13d90a43fd65c","passed":true,"testFailed":false,"description":"The TLS protocol is used by HTTPS to make connections secure. If the browser were to re-use a TLS session, then the session ID could be used to track users across websites."},"Web SQL Database":{"write":"async (key) => {\n      if (!window.openDatabase) {\n        throw new Error(\"gported\");\n      }\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let tx = new Promise((resolve) => database.transaction(tx => {\n        tx.executeSql(\n          `CREATE TABLE IF NOT EXISTS cache(\n             id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n             name TEXT NOT NULL,\n             value TEXT NOT NULL,\n             UNIQUE (name)\n           )`,\n          [], (tx, rs) => {}, (tx, err) => {});\n        tx.executeSql(\n          `INSERT OR REPLACE INTO cache(name, value)\n           VALUES(?, ?)`,\n          [\"secret\", key], (tx, rs) => {}, (tx, rs) => {});\n      }));\n    }","read":"async () => {\n      let database = window.openDatabase(\"sqlite_supercookie\", \"\", \"supercookie\", 1024 * 1024);\n      let result = await new Promise((resolve, reject) => database.transaction(tx => {\n        tx.executeSql(\n          \"SELECT value FROM cache WHERE name=?\",\n          [\"secret\"],\n          (tx, rs) => resolve(rs),\n          (tx, err) => reject(err));\n      }));\n      return result.rows.item(0).value;\n    }","unsupported":false,"readSameFirstParty":"Error: Web SQL is deprecated","readDifferentFirstParty":"Error: Web SQL is deprecated","testFailed":true,"description":"The Web SQL Database is a deprecated web API for storing data in an SQL database."},"H1 connection":{"write":"async (secret) => {\n      await fetch(`https://h1.privacytests2.org:8901/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h1.privacytests2.org:8901/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/1.x are the classic web connection protocols. If these connections are re-used across websites, they can be used to track users."},"H2 connection":{"write":"async (secret) => {\n      await fetch(`https://h2.privacytests2.org:8902/?mode=write&secret=${secret}`, {cache: \"no-store\"});\n    }","read":"async () => {\n      let response = await fetch(`https://h2.privacytests2.org:8902/?mode=read`, {cache: \"no-store\"});\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"047ccb95-eb4e-4563-8a9b-8f11806c6b4c","readDifferentFirstParty":"","passed":true,"testFailed":false,"description":"HTTP/2 is a web connection protocol introduced in 2015. Some browsers re-use HTTP/2 connections across websites and can thus be used to track users."},"H3 connection":{"write":"async (secret) => {\n      // Ensure that we can switch over to h3 via alt-svc:\n      for (let i = 0; i<3; ++i) {\n        await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n        await sleepMs(500);\n      }\n      // Are we now connecting over h3?\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`, {cache: \"no-store\"});\n      let text = await response.text();\n      // Empty response text indicates we are not connecting over h3:\n      if (text.trim() === \"\") {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let response = await fetch(`https://h3.privacytests2.org:4434/connection_id`);\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"fbea5cc67256eaf1cf40be0cf331292a","readDifferentFirstParty":"a14893c22ffd0f2fe515f579ce7c611e","passed":true,"testFailed":false,"description":"HTTP/3 is a new standard HTTP connection protocol, still in draft but widely supported by browsers. If it is not partitioned, it can be used to track users across websites."},"CookieStore":{"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers."},"getDirectory":{"write":"async (secret) => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\", { create: true });\n        const stream = await fileHandle.createWritable();\n        await stream.write(secret);\n        await stream.close();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      try {\n        const root = await navigator.storage.getDirectory();\n        const fileHandle = await root.getFileHandle(\"secret.txt\");\n        const file = await fileHandle.getFile();\n        return file.text();\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","unsupported":true,"readSameFirstParty":"","readDifferentFirstParty":"Error: Unsupported","testFailed":false,"description":"navigator.storage.getDirectory exposes a location for storing files to web content. In some cases, these files may be shared across tabs."},"ServiceWorker":{"write":"async (key) => {\n      if (!navigator.serviceWorker) {\n        throw new Error(\"Unsupported\");\n      }\n      let registration = await navigator.serviceWorker.register(\n        'serviceWorker.js');\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      await fetch(`serviceworker-write?secret=${key}`);\n    }","read":"async () => {\n      console.log(\"trying to register the serviceworker now...\");\n      const registration = await Promise.race([\n        navigator.serviceWorker.register('serviceWorker.js'),\n        sleepMs(500)\n      ]);\n      if (registration === undefined) {\n        // We timed out or otherwise failed.\n        throw new Error(\"ServiceWorker registration failed\");\n      }\n      console.log(registration);\n      await navigator.serviceWorker.ready;\n      console.log(\"service worker ready\");\n      await sleepMs(100);\n      let response = await fetch(\"serviceworker-read\");\n      return await response.text();\n    }","unsupported":false,"readSameFirstParty":"","readDifferentFirstParty":"","testFailed":true,"description":"The ServiceWorker API allows websites to run code in the background and store content in the browser for offline use. If a ServiceWorker can be accessed from multiple websites, it can be abused to track users across sites."},"CSS cache":{"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","unsupported":false,"readSameFirstParty":"fake_5105586286141996","readDifferentFirstParty":"fake_09120900264564025","passed":true,"testFailed":false,"description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites."},"font cache":{"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking."},"image cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"script cache":{"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","unsupported":false,"readSameFirstParty":"2","readDifferentFirstParty":"3","passed":true,"testFailed":false,"description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking."},"prefetch cache":{"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","unsupported":true,"readSameFirstParty":"Error: No requests received","readDifferentFirstParty":"Error: No requests received","testFailed":false,"description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites."},"Alt-Svc":{"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","unsupported":true,"readSameFirstParty":"Error: Unsupported","readDifferentFirstParty":"h3","testFailed":false,"description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned."},"HSTS cache":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":true,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Used http","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"},"HSTS cache (fetch)":{"description":"The HTTP Strict-Transport-Security response header allows a website to signal that it should only be accessed via HTTPS. The browser remembers this directive in a database, but if this database is not partitioned, then it can be used to track users across websites.\"","passed":false,"unsupported":false,"testFailed":false,"readDifferentFirstParty":"Upgraded to https","readSameFirstParty":"not tested","write":"set HSTS flag","read":"read HSTS flag"}},"trackers":{"Google (third-party ad pixel)":{"url":"https://www.google.com/pagead/1p-user-list/","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.google.com/pagead/1p-user-list/"},"Google Tag Manager":{"url":"https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://www.googletagmanager.com/gtag.js?id=GTM-NX4SMZL"},"DoubleClick (Google)":{"url":"https://securepubads.g.doubleclick.net/static/glade.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://securepubads.g.doubleclick.net/static/glade.js"},"Google Analytics":{"url":"https://google-analytics.com/urchin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://google-analytics.com/urchin.js"},"Facebook tracking":{"url":"https://connect.facebook.net/en_US/fbevents.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://connect.facebook.net/en_US/fbevents.js"},"Amazon adsystem":{"url":"https://s.amazon-adsystem.com/dcm","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://s.amazon-adsystem.com/dcm"},"Scorecard Research Beacon":{"url":"https://sb.scorecardresearch.com/internal-c2/default/cs.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://sb.scorecardresearch.com/internal-c2/default/cs.js"},"New Relic":{"url":"https://js-agent.newrelic.com/nr-1212.min.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://js-agent.newrelic.com/nr-1212.min.js"},"Criteo":{"url":"https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dis.criteo.com/dis/rtb/appnexus/cookiematch.aspx"},"Adobe":{"url":"https://munchkin.marketo.net/munchkin.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://munchkin.marketo.net/munchkin.js"},"Adobe Audience Manager":{"url":"https://dpm.demdex.net/ibs","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dpm.demdex.net/ibs"},"AppNexus":{"url":"https://ib.adnxs.com/px?id=178248&t=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://ib.adnxs.com/px?id=178248&t=1"},"Twitter pixel":{"url":"https://t.co/i/adsct","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://t.co/i/adsct"},"Bing Ads":{"url":"https://bat.bing.com/bat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://bat.bing.com/bat.js"},"Taboola":{"url":"https://trc.taboola.com/futureplc-tomsguide/trc/3/json","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://trc.taboola.com/futureplc-tomsguide/trc/3/json"},"Index Exchange":{"url":"https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://dsum-sec.casalemedia.com/crum?cm_dsp_id=10&external_user_id=629685505537&C=1"},"Yandex Ads":{"url":"https://yandex.ru/ads/system/header-bidding.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://yandex.ru/ads/system/header-bidding.js"},"Quantcast":{"url":"https://pixel.quantserve.com/pixel","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://pixel.quantserve.com/pixel"},"Chartbeat":{"url":"https://static.chartbeat.com/js/chartbeat.js","passed":false,"description":"Tests whether the browser blocks the page from loading the tracker at https://static.chartbeat.com/js/chartbeat.js"}}},"timeStarted":"2024-02-02T07:47:39.764Z","reportedVersion":"6.3212.38","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"}],"git":"6515e5cb4e099dde92f66bcf5621af666bb32ad9","timeStarted":"2024-02-02T04:35:51.416Z","timeStopped":"2024-02-02T07:51:28.872Z","platform":"iOS"}