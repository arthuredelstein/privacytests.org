{"all_tests":[{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p_js","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p_http","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7274788552346969","readDifferentSession":"fake_7274788552346969"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p_js","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p_http","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p","readDifferentSession":"63c614fc-000d-49ca-86b8-7b05b34c9f06_3p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5801489997810054","readDifferentSession":"fake_5801489997810054"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T20:53:34.636Z","reportedVersion":"122.0.6261.94","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"firefox","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p_js","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p_http","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_3251405069878335","readDifferentSession":"fake_3251405069878335"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p_js","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p_http","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p","readDifferentSession":"1a246796-eb1d-40e7-bbcf-32d119250502_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8782049298660042","readDifferentSession":"fake_8782049298660042"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T20:53:34.636Z","reportedVersion":"123.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"brave","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p_js","readDifferentSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p_http","readDifferentSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p","readDifferentSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p","readDifferentSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p","readDifferentSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p","readDifferentSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9400312822242285","readDifferentSession":"fake_9400312822242285"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_3p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_3p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_3p","readDifferentSession":null},"indexedDB":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"Error: The user denied permission to access the database.","readDifferentSession":"Error: The user denied permission to access the database."},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: Failed to execute 'open' on 'CacheStorage': An attempt was made to break through the security policy of the user agent.","readDifferentSession":"Error: Failed to execute 'open' on 'CacheStorage': An attempt was made to break through the security policy of the user agent."},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"e4a53288-c9d4-4b9c-9def-c3de8845d40f_3p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9085790344808664","readDifferentSession":"fake_9085790344808664"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T20:53:34.636Z","reportedVersion":"1.63.162","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"safari","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_1p_http","readDifferentSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_1p_http"},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_944845454051962","readDifferentSession":"fake_944845454051962"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"15bfe853-ea1f-464e-a4ff-8dc09f7d2304_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9659670924079575","readDifferentSession":"fake_9659670924079575"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T20:53:34.636Z","reportedVersion":"17.3","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"edge","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_1p_js","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_1p_http","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_1p","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_1p","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_1p","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_1p","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_05651310315886171","readDifferentSession":"fake_05651310315886171"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_3p_js","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_3p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_3p_http","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_3p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_3p","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_3p","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_3p","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"8f641515-7617-4781-a990-95c4d5900990_3p","readDifferentSession":"8f641515-7617-4781-a990-95c4d5900990_3p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9313245474427261","readDifferentSession":"fake_9313245474427261"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T20:53:34.636Z","reportedVersion":"122.0.2365.59","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"ungoogled","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p_js","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p_http","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6473196592877242","readDifferentSession":"fake_6473196592877242"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_3p","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_3p","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"79a1acc6-3571-4f26-8963-daaa42273c68_3p","readDifferentSession":"79a1acc6-3571-4f26-8963-daaa42273c68_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":null,"readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9626905088488602","readDifferentSession":"fake_9626905088488602"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T20:53:34.636Z","reportedVersion":"122.0.6261.69","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"}],"git":"80fc570d31071130f3fe7e4c677e299bad287783","timeStarted":"2024-02-28T20:53:34.619Z","timeStopped":"2024-02-28T20:56:08.613Z","platform":"Desktop"}