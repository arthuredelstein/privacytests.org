{"all_tests":[{"browser":"safari","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_1p_http","readDifferentSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_1p_http"},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_1p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_22180626115202728","readDifferentSession":"fake_22180626115202728"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"7c6b544f-fe6f-429c-a2fa-45c00838895c_3p","readDifferentSession":"Error: undefined is not an object (evaluating 'cacheKeys[0].url')"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_37493396205940654","readDifferentSession":"fake_37493396205940654"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"17.3","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"firefox","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p_js","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p_http","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_8740490423302081","readDifferentSession":"fake_8740490423302081"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p_js","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p_http","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"2","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p","readDifferentSession":"e0ad5e1f-9894-4f70-8928-ecaf54151a46_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6324853278002736","readDifferentSession":"fake_6324853278002736"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"123.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"tor","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"8aec3779-11e5-46ce-b47b-72c88ea46871_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"8aec3779-11e5-46ce-b47b-72c88ea46871_1p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"8aec3779-11e5-46ce-b47b-72c88ea46871_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"8aec3779-11e5-46ce-b47b-72c88ea46871_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: The operation is insecure.","readDifferentSession":"Error: The operation is insecure."},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_06864013701125438","readDifferentSession":"fake_5048132858269136"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"Error: The operation is insecure.","readDifferentSession":"Error: The operation is insecure."},"indexedDB":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"Error: The operation is insecure.","readDifferentSession":"Error: The operation is insecure."},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: The operation is insecure.","readDifferentSession":"Error: The operation is insecure."},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_9823095006333922","readDifferentSession":"fake_7239648952178797"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"13.0.10","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"brave","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p_js","readDifferentSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p_http","readDifferentSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p","readDifferentSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p","readDifferentSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p","readDifferentSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p","readDifferentSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_592952576991282","readDifferentSession":"fake_592952576991282"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_3p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_3p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_3p","readDifferentSession":null},"indexedDB":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"Error: The user denied permission to access the database.","readDifferentSession":"Error: The user denied permission to access the database."},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: Failed to execute 'open' on 'CacheStorage': An attempt was made to break through the security policy of the user agent.","readDifferentSession":"Error: Failed to execute 'open' on 'CacheStorage': An attempt was made to break through the security policy of the user agent."},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"958cce23-5f13-4fbd-b3f7-ca50cc7e7365_3p","readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_6869944426753429","readDifferentSession":"fake_6869944426753429"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"1.63.162","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"chrome","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_1p_js","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_1p_http","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_1p","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_1p","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_1p","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_1p","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_525230581873382","readDifferentSession":"fake_525230581873382"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_3p_js","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_3p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_3p_http","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_3p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_3p","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_3p","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_3p","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"7da13732-3c53-427e-9abd-8b169265c251_3p","readDifferentSession":"7da13732-3c53-427e-9abd-8b169265c251_3p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7189257963849918","readDifferentSession":"fake_7189257963849918"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"122.0.6261.94","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"edge","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p_js","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p_http","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_5634823450788415","readDifferentSession":"fake_5634823450788415"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p_js","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p_http","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p","readDifferentSession":"bbe74512-5b59-4f99-91ca-bf61f63c6d86_3p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_2986716458707266","readDifferentSession":"fake_2986716458707266"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"122.0.2365.59","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"opera","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p_js","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p_http","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_4265276446363986","readDifferentSession":"fake_4265276446363986"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p_js","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p_http","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p","readDifferentSession":"3d96250c-ed7a-43de-bf59-9c36a69da147_3p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_807623413520902","readDifferentSession":"fake_807623413520902"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"107.0","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"vivaldi","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p_js","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p_http","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"2","readDifferentSession":"2"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_3356564167997882","readDifferentSession":"fake_3356564167997882"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p_js","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p_http","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"2","readDifferentSession":"2"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p","readDifferentSession":"aafdb83e-fdfb-4559-b533-89b0834726f5_3p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_29427454342457193","readDifferentSession":"fake_29427454342457193"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"6.5.3206.63","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"librewolf","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_1p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_1p","readDifferentSession":"Error: cacheKeys[0] is undefined"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_31084242166538223","readDifferentSession":"fake_7508634785672672"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_3p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_3p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_3p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_3p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"2945fb6b-dea5-450e-9cde-bcbed5b43829_3p","readDifferentSession":"Error: cacheKeys[0] is undefined"},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_016584469522803458","readDifferentSession":"fake_8847484719825427"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"123.0-1","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"ungoogled","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p_js","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p_js"},"cookie (HTTP)":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p_http","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p_http"},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":false,"passed":false,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_1p"},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_4052570329370391","readDifferentSession":"fake_4052570329370391"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":false,"passed":false,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h3"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_3p","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_3p"},"indexedDB":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_3p","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_3p"},"fetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"XMLHttpRequest cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"1"},"iframe cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"CacheStorage":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_3p","readDifferentSession":"cfa54827-f9b7-4cdd-9e63-ef41e09a21c8_3p"},"favicon cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":null,"readDifferentSession":null},"CSS cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_722451960924199","readDifferentSession":"fake_722451960924199"},"image cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"script cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"font cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"1"},"prefetch cache":{"unsupported":false,"passed":false,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"1"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"122.0.6261.69","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"},{"browser":"mullvad","incognito":false,"tor":false,"nightly":false,"testResults":{"session_1p":{"cookie (JS)":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"6383aace-d2ca-4ac0-a601-af7b83a1c849_1p_js","readDifferentSession":null},"cookie (HTTP)":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":"6383aace-d2ca-4ac0-a601-af7b83a1c849_1p_http","readDifferentSession":null},"localStorage":{"unsupported":false,"passed":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"6383aace-d2ca-4ac0-a601-af7b83a1c849_1p","readDifferentSession":null},"indexedDB":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"6383aace-d2ca-4ac0-a601-af7b83a1c849_1p"},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: The operation is insecure.","readDifferentSession":"Error: The operation is insecure."},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_11497671495341089","readDifferentSession":"fake_9881258154983579"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":false,"passed":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h3","readDifferentSession":"h2"}},"session_3p":{"cookie (JS)":{"unsupported":true,"testFailed":false,"write":"(secret) => {\n      document.cookie = `secret=${secret}_js; max-age=3600; SameSite=None; Secure`;\n    }","read":"() => document.cookie ? document.cookie.match(/secret=([\\w-]+)/)[1] : null","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"cookie (HTTP)":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      // Request a page that will send an HTTPOnly 'set-cookie' response header with secret value.\n      await fetch(`${baseURI}cookie?secret=${secret}_http`);\n    }","read":"async () => {\n      // Test if we now send a requests with a 'cookie' header containing the secret.\n      let response = await fetch(`${baseURI}headers`);\n      let cookie = (await response.json())[\"cookie\"];\n      return cookie ? cookie.match(/secret=([\\w-]+)/)[1]: null;\n    }","description":"The cookie, first introduced by Netscape in 1994, is a small amount of data stored by your browser on a website's behalf. It has legitimate uses, but it is also the classic cross-site tracking mechanism, and today still the most popular method of tracking users across websites. Browsers can stop cookies from being used for cross-site tracking by either blocking or partitioning them.","readSameSession":null,"readDifferentSession":null},"localStorage":{"unsupported":true,"testFailed":false,"write":"(secret) => localStorage.setItem(\"secret\", secret)","read":"() => localStorage.getItem(\"secret\")","description":"The localStorage API gives websites access to a key-value database that will remain available across visits. If the localStorage API is not partitioned or blocked, it can also be used to track users across websites.","readSameSession":"Error: The operation is insecure.","readDifferentSession":"Error: The operation is insecure."},"indexedDB":{"unsupported":true,"testFailed":false,"write":"async (secret) => {\n      try {\n        return await IdbKeyVal.set(\"secret\", secret);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"() => IdbKeyVal.get(\"secret\")","description":"The IndexedDB API exposes a transactional database to web pages. That database can be used to track users across websites, unless it is partitioned.","readSameSession":"Error: The operation is insecure.","readDifferentSession":"Error: The operation is insecure."},"fetch cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      return key;\n    }","read":"async (key) => {\n      let response = await fetch(testURI(\"resource\", \"fetch\", key),\n                                 {cache: \"force-cache\"});\n      let countResponse = await fetch(testURI(\"ctr\", \"fetch\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"When a resource is received via the Fetch API, it is frequently cached. That cache can potentially be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"XMLHttpRequest cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      return key;\n    }","read":"async (key) => {\n      const req = new XMLHttpRequest();\n      const loadPromise = new Promise(resolve => req.addEventListener(\"load\", resolve));\n      req.open(\"GET\", testURI(\"resource\", \"xhr\", key));\n      req.send();\n      await loadPromise;\n      let countResponse = await fetch(testURI(\"ctr\", \"xhr\", key),\n                                      {cache: \"reload\"});\n      return (await countResponse.text()).trim();\n    }","description":"Similar to the newer Fetch API, any resource received may be cached by the browser. The cache is potentially vulnerable to cross-site tracking attack.","readSameSession":"1","readDifferentSession":"2"},"iframe cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      iframe.addEventListener(\"load\", () => resolve(key), {once: true});\n      iframe.src = testURI(\"resource\", \"page\", key);\n    })","read":"async (key) => {\n      let iframe = document.createElement(\"iframe\");\n      document.body.appendChild(iframe);\n      let iframeLoadPromise = new Promise((resolve, reject) => {\n        iframe.addEventListener(\"load\", resolve, {once: true});\n      });\n      let address = testURI(\"resource\", \"page\", key);\n      iframe.src = address;\n      await iframeLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"page\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"An iframe is an element in a web page than allows websites to embed a second web page. Caching of this web page could be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"CacheStorage":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      try {\n        let cache = await caches.open(\"supercookies\");\n        cache.addAll([`test.css?key=${key}`]);\n      } catch (e) {\n        throw new Error(\"Unsupported\");\n      }\n    }","read":"async () => {\n      let cache = await caches.open(\"supercookies\");\n      let cacheKeys = await cache.keys();\n      let url = cacheKeys[0].url;\n      return (new URL(url)).searchParams.get(\"key\");\n    }","description":"The Cache API is a content storage mechanism originally introduced to support ServiceWorkers. If the same Cache object is accessible to multiple websites, it can be abused to track users.","readSameSession":"Error: The operation is insecure.","readDifferentSession":"Error: The operation is insecure."},"favicon cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => key","read":"async (key) => {\n      // Wait for the favicon to load (defined in supercookies.html)\n      await sleepMs(2000);\n      let response = await fetch(\n        testURI(\"ctr\", \"favicon\", key), {\"cache\": \"reload\"});\n      let count = (await response.text()).trim();\n      if (count === \"0\") {\n        throw new Error(\"No requests received\");\n      }\n      return count;\n    }","description":"A favicon is an icon that represents a website, typically shown in browser tab and bookmarks menu. If the favicon cache is not partitioned, it can be used to track users across websites.","readSameSession":"1","readDifferentSession":"2"},"CookieStore":{"unsupported":true,"testFailed":false,"write":"(data) => {\n      const msPerHour = 60 * 60 * 1000;\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      window.cookieStore.set({\n        name: \"partition_test\",\n        value: data,\n        expires: Date.now() + msPerHour,\n        sameSite: \"none\"\n      });\n    }","read":"async () => {\n      if (!window.cookieStore) {\n        throw new Error(\"Unsupported\");\n      }\n      const cookie = await window.cookieStore.get(\"partition_test\");\n      if (!cookie) {\n        return null;\n      }\n      return cookie.value;\n    }","description":"The Cookie Store API is an alternative asynchronous API for managing cookies, supported by some browsers.","readSameSession":"Error: Unsupported","readDifferentSession":"Error: Unsupported"},"CSS cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return key;\n    }","read":"async (key) => {\n      const href = testURI(\"resource\", \"css\", key);\n      const head = document.getElementsByTagName(\"head\")[0];\n      head.innerHTML += `<link type=\"text/css\" rel=\"stylesheet\" href=\"${href}\">`;\n      const testElement = document.querySelector(\"#css\");\n      let fontFamily;\n      while (true) {\n        await sleepMs(100);\n        fontFamily = getComputedStyle(testElement).fontFamily;\n        if (fontFamily.startsWith(\"fake\")) {\n          break;\n        }\n      }\n      console.log(fontFamily);\n      return fontFamily;\n    }","description":"CSS stylesheets are cached, and if that cache is shared between websites, it can be used to track users across sites.","readSameSession":"fake_7189009808922844","readDifferentSession":"fake_9514892260746435"},"image cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      img.addEventListener(\"load\", () => resolve(key), {once: true});\n      img.src = testURI(\"resource\", \"image\", key);\n    })","read":"async (key) => {\n      let img = document.createElement(\"img\");\n      document.body.appendChild(img);\n      let imgLoadPromise = new Promise((resolve, reject) => {\n        img.addEventListener(\"load\", resolve, {once: true});\n      });\n      img.src = testURI(\"resource\", \"image\", key);\n      await imgLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"image\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of images in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"script cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"(key) => new Promise((resolve, reject) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      script.addEventListener(\"load\", () => resolve(key), {once: true});\n      script.src = testURI(\"resource\", \"script\", key);\n    })","read":"async (key) => {\n      let script = document.createElement(\"script\");\n      document.body.appendChild(script);\n      let scriptLoadPromise = new Promise((resolve, reject) => {\n        script.addEventListener(\"load\", resolve, {once: true});\n      });\n      script.src = testURI(\"resource\", \"script\", key);\n      await scriptLoadPromise;\n      let response = await fetch(\n        testURI(\"ctr\", \"script\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Caching of scripts in web browsers is a standard behavior. But if that cache leaks between websites, it can be abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"font cache":{"unsupported":false,"passed":true,"testFailed":false,"write":"async (key) => {\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } body { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      return key;\n    }","read":"async (key) => {\n      const text = document.createElement(\"span\");\n      text.id = \"text\";\n      text.innerText = \"test\";\n      document.body.appendChild(text);\n      const originalWidth = text.getBoundingClientRect().width;\n      let style = document.createElement(\"style\");\n      style.type='text/css';\n      let fontURI = testURI(\"resource\", \"font\", key);\n      style.innerHTML = `@font-face {font-family: \"myFont\"; src: url(\"${fontURI}\"); } #text { font-family: \"myFont\" }`;\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      let newWidth;\n      do {\n        await sleepMs(100);\n        newWidth = text.getBoundingClientRect().width;\n      } while (newWidth < 0 || newWidth === originalWidth)\n      let response = await fetch(\n        testURI(\"ctr\", \"font\", key), {\"cache\": \"reload\"});\n      return (await response.text()).trim();\n    }","description":"Web fonts are sometimes stored in their own cache, which is vulnerable to being abused for cross-site tracking.","readSameSession":"1","readDifferentSession":"2"},"prefetch cache":{"unsupported":true,"testFailed":false,"write":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      return key;\n    }","read":"async (key) => {\n      let link = document.createElement(\"link\");\n      link.rel = \"prefetch\";\n      link.href = testURI(\"resource\", \"prefetch\", key);\n      document.getElementsByTagName(\"head\")[0].appendChild(link);\n      await sleepMs(500);\n      let response = await fetch(\n        testURI(\"ctr\", \"prefetch\", key), {\"cache\": \"reload\"});\n      let countString = (await response.text()).trim();\n      if (parseInt(countString) === 0) {\n        throw new Error(\"No requests received\");\n      }\n      return countString;\n    }","description":"A <link rel='prefetch'...> suggests to browsers they should fetch a resource ahead of time and cache it. But if browsers don't partition this cache, it can be used to track users across websites.","readSameSession":"Error: No requests received","readDifferentSession":"Error: No requests received"},"Alt-Svc":{"unsupported":true,"testFailed":false,"write":"async () => {\n      // Clear Alt-Svc caching first.\n      let responseText = \"\";\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/clear\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after clear:\", responseText);\n      // Store \"h3\" state in Alt-Svc cache\n      for (let i = 0; i < 3; ++i) {\n        await fetch(altSvcOrigin + \"/set\");\n        await sleepMs(100);\n      }\n      responseText = await fetchText(altSvcOrigin + \"/protocol\");\n      console.log(\"after set:\", responseText);\n    }","read":"async () => {\n      const protocol = await fetchText(altSvcOrigin + \"/protocol\");\n      if ((new URL(location)).searchParams.get(\"thirdparty\") === \"same\") {\n        if (protocol !== \"h3\") {\n          throw new Error(\"Unsupported\");\n        }\n      }\n      return protocol;\n    }","description":"Alt-Svc allows the server to indicate to the web browser that a resource should be loaded on a different server. Because this is a persistent setting, it could be used to track users across websites if it is not correctly partitioned.","readSameSession":"h2","readDifferentSession":"h2"}}},"timeStarted":"2024-02-28T23:30:41.744Z","reportedVersion":"13.0.10","os":"Darwin","os_version":"Darwin Kernel Version 23.3.0: Wed Dec 20 21:30:27 PST 2023; root:xnu-10002.81.5~7/RELEASE_ARM64_T8103"}],"git":"80fc570d31071130f3fe7e4c677e299bad287783","timeStarted":"2024-02-28T23:30:41.729Z","timeStopped":"2024-02-28T23:35:46.268Z","platform":"Desktop"}